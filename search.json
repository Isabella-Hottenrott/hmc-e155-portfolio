[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Isabella’s Blog Page\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBlog 1\n\n\nReflections on Lab 1\n\n\n\n\n\nSep 4, 2025\n\n\nBella Hottenrott\n\n\n\n\n\n\n\n\n\n\n\n\nBlog 0\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 28, 2025\n\n\nBella Hottenrott\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "project.html",
    "href": "project.html",
    "title": "E155 Project",
    "section": "",
    "text": "This project implements hang gesture recognition to complete a human-vs-computer rock–paper–scissors system. Five time-multiplexed VL53L0X LiDAR modules embedded beneath a constrained scanning platform capture hand pose signatures, enabling classification of rock, paper, and scissors while mitigating cross-sensor interference and off-angle reflection loss. An FPGA drives an LCD display for real-time game feedback, and interfaces with an MCU that executes the computer’s move logic. The design’s primary technical challenge lies in achieving reliable gesture discrimination across diverse users through precise synchronized ranging and signal integration.\nAs an extension to this project, I will be pursuing my own investigation into the Lattice SensAI Demo for Hand Gesture Detection. This is an FPGA based AI implementation of hand gesture recognition through the compact on-board CNN."
  },
  {
    "objectID": "project.html#project-proposal",
    "href": "project.html#project-proposal",
    "title": "E155 Project",
    "section": "Project Proposal",
    "text": "Project Proposal\nProject Proposal"
  },
  {
    "objectID": "project.html#midway-check-in",
    "href": "project.html#midway-check-in",
    "title": "E155 Project",
    "section": "Midway Check-In",
    "text": "Midway Check-In\nMidWay Check In"
  },
  {
    "objectID": "project.html#project-extension",
    "href": "project.html#project-extension",
    "title": "E155 Project",
    "section": "Project Extension",
    "text": "Project Extension\nProject Extension"
  },
  {
    "objectID": "project/projectextension.html",
    "href": "project/projectextension.html",
    "title": "Project Extension",
    "section": "",
    "text": "Project Extension\nAfter going down a little hole of watching Youtube videos about Neural Networks and playing with Hugging Face Notebooks over summer, I thought it could be cool to integrate electrical engineering and hardware.\nI have purchased and am waiting on my Himax CMOS Imaging Camera (HM01b0) to arrive. I did not purchase the Himax HM01B0 Adapter Board for cost reasons. Because of this, I will have to configure communication between the camera and the FPGA board myself, as well as take whatever setup is necessary to get the CNN on my FPGA board, instead of flashing everything onto the adapter board. This deviates from the Demo, so I will have to figure out the solution on my own. The demo shield board also has Debug LEDs, which I will likely want to integrate into my own system.\nFurther on, the neural network can be retrained to detect other gestures, which I might be interested to explore."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Bella Hottenrott is a senior Engineering major at Harvey Mudd College. Her background lies in electrical, computer, and controls engineering. Outside of work, she and her friends like to go surfing and exploring art galleries or music events in LA. In her own time she likes listening to podcasts, going on a run, and making coffee."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Blog 0",
    "section": "",
    "text": "I am excited to take E155 this semester. I remember seeing the seniors going to lab for this class when I was a freshman. Now I am in my final year and feel I have a strong enough engineering background to take this course. I am excited to challenge myself. Most of all, I am excited to build the resilience and debugging skills that this course develops.\nI found Lab 0 relatively easy. It allowed me to reflect on the Git, Linux, and Quarto familiarity that I’ve gained over the past year. I am not sure that I would have been able to set up this portfolio a year ago."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "Lab 4: Digital Audio\nSOURCE CODE\n\nIntroduction\nIn this lab, two general-purpose timers on the STM32L432KC board were used to generate square waves at specified frequencies and play Beethoven’s Für Elise over a GPIO pin. This required understanding and configuring several on-chip peripherals using the STM32L432KC reference manual and datasheet. In addition, a low-voltage audio amplifier circuit was assembled to drive a Jameco 8 Ω speaker and provide volume control.\n\n\nDesign and Testing Methodology\nThe internal clock was first multiplied using the PLL to obtain an 80 MHz system clock. This 80 MHz clock was then selected as the system clock source and routed onto the APB2 and AHB2 buses so that both the timers and GPIO peripherals could access it. Two general-purpose timers were used: TIM15 for frequency generation and TIM16 for note duration timing. Both timers were configured using the relationship between the prescaler (PSC), auto-reload register (ARR), and timer input clock.\n\\[\nFdesired =\n\\frac{Ftim}{(2*(PSC + 1)*(ARR + 1))}\n\\]\nand\n\\[\nDurdesired =\n\\frac{(4*(PSC + 1)*(ARR + 1))}{Ftim}\n\\]\nA C for loop iterated through an array of pitch–duration pairs encoding the score for Für Elise. For each entry: * TIM15 set the output frequency and toggled a GPIO pin at the desired note pitch. * TIM16 measured the corresponding note duration.\nBoth behaviors were driven by the update interrupt flag in the timers’ status registers (SR).\nThe following desmos sheet was used to verify the frequencies of the Timer 15 are correct.\nThe following desmos sheet was used to verify the durations of the Timer 16 are correct.\nTwo helper functions, set_hz() and config_delay(), encapsulated the frequency and duration configuration logic. These functions were called from within the main for loop in main.c.\nThe GPIO bank B was initialized to toggle pin 6 for audio output.\n\n\nTechnical Documentation\nAfter analyzing the reference manual and understanding what was required for this design, the following registers were configured.\nFLASH: ACR RCC: CR, PLLCFGR, CFGR, APB2ENR, AHB2ENR GPIO: MODER, ODC TIM15: PSC, EGR, CR1, ARR, SR, CNT TIM16: PSC, EGR, CR1, ARR, SR, CNT\nThe below calculations were used to determine an appropriate prescaler and auto-reload-register value:\nThe values for the PSC and ARR registers were selected using the considerations below.\n\n\n\nFigure 1: Frequency PSC and ARR calculations\n\n\nTIM16: A prescaler of 1\\2000 was selected, so PSC was loaded with 1999. ARR values for the required note durations were computed at runtime inside config_delay() and verified using desmos sheet.\nTIM 15: A prescaler of 20 was selected, so PSC was loaded with 19. ARR values for the required note frequencies were computed at runtime inside set_hz() and verified using desmos sheet.\nThese values are proven to fall within 1% of the desired frequencies. The ARR values of the register were recorded over the Segger Registers window. These were used to derive the resulting frequency of the output signal. Calculations can be found using the following desmos. All unique notes were tested.\n\n\n\nFigure 2: Frequency Percentage Deviation Calculation\n\n\nFrom these settings, the minimum and maximum achievable frequencies were derived:\n\n\n\nFigure 3: Minimum Frequency Calculations\n\n\n\n\n\nFigure 4: Maximum Frequency Calculations\n\n\nIn addition to Für Elise, a short custom composition playing a German Happy Birthday song was written. The following fixed 2D array of frequencies and durations was written.\n\n\nSchematic\nThe audio amplifier circuit followed the recommended configuration from the LM386 datasheet. The following schematic was implemented in hardware.\n\n\n\nFigure 6: Schematic\n\n\n\n\nBlock Diagram\nAn abstracted block diagram of the overall system is shown below:\n\n\n\nFigure 7: Abstracted Block Diagram\n\n\n\n\nResults and Discussion\nThe design successfully generated the pitches and durations required to assemble Für Elise from individual notes. The audio amplifier circuit was compact, straightforward to assemble, and produced a clearly audible output on the 8 Ω speaker. For the modest frequency range used in this lab, the chosen timer configuration and GPIO toggling approach were simple, reliable, and did not introduce noticeable timing issues, so I decided to pursue this design.\n\n\nConclusion\nThis project provided hands-on experience with the STM32L432KC’s clock tree, general-purpose timers, GPIO configuration, and the process of navigating the reference manual and datasheet. It also offered a creative opportunity to implement and parameterize musical pieces—both a classical work and a custom composition—using low-level embedded C and on-chip peripherals.\n\n\nAI Prototype Summary\nI provided the LLM with: “What timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?””\nThe LLM’s response, as well as my evaluation of the response, can be found here"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "Lab 2: Multiplexed 7-Segment Display\nSOURCE CODE\n\nIntroduction\nIn this lab, a design was implemented on the UPduino v3.1 FPGA to time-multiplex a dual seven-segment display. The design used a single set of GPIO pins and a single seven-segment HDL module, switching between the two digits at a rate high enough that the multiplexing was not perceptible to the human eye.\n\n\nDesign and Testing Methodology\nThe iCE40 UltraPlus HSOSC primitive generated the main clock, which was divided down to 60 Hz as the base refresh frequency for the display. At this rate, the human eye can no longer perceive individual refresh events, and bleeding between digits is minimized.\nAn 8-position DIP switch controlled the HDSP-521A dual seven-segment display. The lower four switches set the value for the first digit. The upper four switches set the value for the second digit.\nWhen the internal multiplexing clock was low, the first four switch inputs were selected and the first digit’s anode was driven. When the clock was high, the second set of four switches was selected and the second digit’s anode was driven.\nThe sum of the two hex values displayed on the HDSP-521A was shown in binary on the on-board LEDs of the E155 Development Board. These LEDs were placed in series with 1 kΩ resistors to limit current.\nThe Seven Segment Display module- a priority encoder- converted the 4-bit switch inputs into the corresponding seven-segment code. The HDSP-521A required more current than the FPGA could supply directly, so two 2N3906 PNP transistors were used to drive the common anodes. Each segment cathode was connected through a 330 Ω current-limiting resistor to achieve approximately 3 mA of segment current over the effective voltage drop:\n\n\n\nFigure 0: Resistor Calculation\n\n\nA 460 Ω resistor was placed between each transistor base and its corresponding GPIO pin to keep the base current below 5 mA, as specified in the datasheet. The calculation for this value is shown in Figure 1.\n\n\n\nFigure 1: Transistor Base Current Calculation\n\n\nTo control the input to the Seven Segment Display, a priority encoder was used. The output signals were mapped to their respective pins on the input of the HDSP-511A Seven Segment Display.\n\n\nBlock Diagram\n\n\n\nFigure 2: Block Diagram of the lab2_ih verilog design\n\n\nThe block diagram above illustrates the lab2_ih design. The top level module, lab2_ih, takes in inputs: reset, sw1, and sw2. The module outputs to outputs to five leds (led), a single set of GPIO pins for the dual seven segment (segs), to both transistors to illuminate the proper segment anode (anodeOne, anodeTwo), and to the two remaining on-board LEDs to keep them from floating (bottomLEDs). Lab2_ih instantiates five submodules: the high-speed oscillator block (hf_osc), the clock divider to 60 Hz (clock_div), the adder (adder), the seven segments priority encoder (segments), and the anode-selecting module (anodeselect).\n\n\nSchematic\nThe schematic shows the physical layout of the breadboard. Corresponding segment cathodes from the two digits of the dual display are tied together (e.g., segment A of digit 1 shares a node with segment A of digit 2). Each shared node is connected through a 330 Ω current-limiting resistor to a GPIO pin.\nThe on-board LEDs use 1 kΩ series resistors for current limiting. For each PNP transistor, the emitter is connected to 3.3 V, the collector is connected to the common anode of one digit, and the base is driven through a 460 Ω resistor from the FPGA output. This keeps the base current below 5 mA and within the FPGA’s current specifications.\n\n\n\nFigure 3: Schematic of the Breadboard\n\n\n\n\nResults and Discussion\nThe design met all intended objectives. The DIP switches correctly drove the two hex digits, the binary sum displayed on the on-board LEDs matched the expected values, and the dual seven-segment display showed two stable, distinct hex values with no discernible flicker or bleeding.\n\n\nTestbench Simulation\nA testbench simulation was produced for every module in the design.\n\ntb_lab2_ih:\nThe testbench for lab2_ih can be found here. For this simulation, the high-speed oscillator primitive was commented out and replaced with a test clock. Ten known input cases were applied and the outputs were compared against expected values. No mismatches were observed.\n\n\n\nFigure 4: Testbench Simulation Results for lab2_ih\n\n\n\n\ntb_segments:\nThe testbench for the segments module can be found here. All possible 4-bit input combinations were exercised, and the resulting seven-segment outputs were verified to match the expected patterns. No errors occurred.\n\n\n\nFigure 5: Testbench Simulation Results for segments\n\n\n\n\ntb_clock_div:\nThe testbench for the clock divider module can be found here. A test oscillator was created that toggled every 800,000 time steps (with two time steps representing one full clock cycle). The divider’s output was compared against this reference. The HSOSC provides a 48 MHz clock, and the divider reduces it by a factor of 800,000 to 60 Hz. The simulated divided clock matched the reference, confirming correct frequency division. No errors occurred.\n\n\n\nFigure 6: Testbench Simulation Results for clock_div\n\n\n\n\ntb_anodeselect:\nThe testbench for the anodeselect module can be found here. Twelve handwritten test vectors were applied to verify that the 4-bit input produces the correct output from the segments module at each phase of the multiplexing clock, and that only one anode is ever asserted high. All checks passed with no errors.\n\n\n\nFigure 7: Testbench Simulation Results for anodeselect\n\n\n\n\ntb_adder:\nThe testbench for the adder module can be found here. A SystemVerilog function iterated through all possible input combinations to verify the correctness of the sum. All additions produced the expected binary output, and no errors occurred.\n\n\n\nFigure 8: Testbench Simulation Results for adder\n\n\n\n\n\nConclusion\nThis design successfully drove a dual seven-segment display using a single seven-segment decoder through time-multiplexing. The BJT ensured that sufficient, but not excessive, current flowed through each segment in accordance with the component datasheets. The design functioned correctly in both hardware and simulation, and met all specified objectives.\n\n\nAI Prototype Summary\nThe prompt that I provided the LLM was: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.”\nThe LLM’s response, as well as my evaluation of the response, can be found here"
  },
  {
    "objectID": "labs/labs.html",
    "href": "labs/labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1: FPGA and MCU Setup and Testing"
  },
  {
    "objectID": "labs/labs.html#lab-1",
    "href": "labs/labs.html#lab-1",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1: FPGA and MCU Setup and Testing"
  },
  {
    "objectID": "labs/labs.html#lab-2",
    "href": "labs/labs.html#lab-2",
    "title": "E155 Labs",
    "section": "Lab 2",
    "text": "Lab 2\nLab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs/labs.html#lab-3",
    "href": "labs/labs.html#lab-3",
    "title": "E155 Labs",
    "section": "Lab 3",
    "text": "Lab 3\nLab 3: Keypad Scanner"
  },
  {
    "objectID": "labs/labs.html#lab-4",
    "href": "labs/labs.html#lab-4",
    "title": "E155 Labs",
    "section": "Lab 4",
    "text": "Lab 4\nLab 4: Digital Audio"
  },
  {
    "objectID": "labs/labs.html#lab-5",
    "href": "labs/labs.html#lab-5",
    "title": "E155 Labs",
    "section": "Lab 5",
    "text": "Lab 5\nLab 5: Interrupts"
  },
  {
    "objectID": "labs/labs.html#lab-6",
    "href": "labs/labs.html#lab-6",
    "title": "E155 Labs",
    "section": "Lab 6",
    "text": "Lab 6\nLab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Lab 1: FPGA and MCU Setup and Testing\nSOURCE CODE\n\nIntroduction\nThis lab implemented a simple design on the UPduino v3.1 FPGA to validate proper assembly and functionality of the E155 Development Board. This lab demonstrated correct operation of the development board’s LEDs, the FPGA’s on-board high-speed oscillator, and a seven-segment display.\n\n\nDesign and Testing Methodology\nThe iCE40 UltraPlus HSOSC primitive was used to generate a clock signal at 48 MHz. A separate clock divider module was created to divide the HSOSC signal to a frequency of 2.4 Hz using a counter that reset every 10,000 counts, and providing a slow blink signal for an external LED.\nControl logic for the remaining on-board LEDs consisted of simple combinational operations (XOR and AND) driven by the switch inputs.\nA priority encoder was used to select which segment of the seven-segment display would illuminate. Its outputs were mapped to the pins of an HDSP-511A common-anode display. Each segment was activated by grounding its corresponding GPIO pin, producing the required 3.3 V drop across the diode. With a forward voltage of 1.95 V and a desired diode current of around 5 mA, 330 Ω series resistors were selected as current-limiting elements. The corresponding calculations are shown in Figure 1.\n\n\n\nFigure 1: Calculations for the current-limiting resistor values\n\n\nTo deactivate a segment, the GPIO pin was driven high to eliminate voltage drop and prevent current flow.\n\n\nTechnical Documentation\nThe source code for Lab 1 can be found in the following GitHub repository.\n\nBlock Diagram\n\n\n\nFigure 2: Block Diagram of the lab1_ih verilog design\n\n\nThe top-level module, lab1_ih, accepts switch inputs s[3:0] and drives outputs led[2:0] and segs[6:0]. It instantiates three submodules: the high-speed oscillator (hf_osc), the seven-segment priority encoder (segments), and the 2.4 Hz clock divider (clock_div).\n\n\nSchematic\n\n\n\nFigure 3: Schematic of the Physical Circuit\n\n\nThe schematic illustrates the breadboard wiring, including the 300 Ω series resistors used to limit current to both the seven-segment display and the on-board LEDs. Internal 100 kΩ pull-ups ensured that the active-low switch (SW7) did not float.\n\n\n\nResults and Discussion\nThe design met all functional objectives. Switch inputs produced the correct LED and seven-segment display behavior, verified both experimentally and through simulation. Testbenches were developed for all modules, confirming correct logic.\n\n\nTestbench Simulation\n\n\n\nFigure 5: Waveforms for tb_lab1_ih\n\n\nThe lab1_ih testbench evaluated all combinations of switch inputs. Output waveforms for both the LEDs and the seven-segment display matched expected behavior. The HSOSC primitive was instantiated in simulation to validate clock-driven logic.\n\n\n\nFigure 6: Waveforms for tb_segments\n\n\nThe segments module testbench confirmed correct encoding for all input combinations. Segment outputs matched the expected one-hot activations.\n\n\n\nFigure 7: Waveforms for tb_clock_div\n\n\nThe clock_div testbench generated a model oscillator ticking every 20,000,000 simulation time units, corresponding to the intended 2.4 Hz blink frequency derived from a 48 MHz input clock. The divided clock output aligned precisely with the modeled reference.\n\n\nConclusion\nThis lab successfully demonstrated correct operation of the UPduino v3.1 FPGA and the E155 Development Board. The design verified the board’s assembly, confirmed the functionality of the on-board HSOSC, and produced correct LED and seven-segment display behavior.\n\n\nAI Prototype Summary\nThe prompt that I provided the LLM was: “Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”\nThe LLM’s response, as well as my evaluation of the response, can be found here"
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface\n\nIntroduction\nIn this lab, an IoT device was implemented to control an LED and read temperature measurements from a DS1722 digital thermometer at a user-selectable resolution. An ESP8266 WiFi development board hosted a webpage generated by the MCU. The webpage allowed the user to:\n•   Toggle an on-board LED\n•   Select the temperature sensor’s resolution (8–12 bits)\n•   View the current temperature reading in °C\nCommunication between the MCU and ESP8266 occurred over UART, while the MCU communicated with the DS1722 thermometer via SPI.\nThe webpage accurately reflected the LED state and selected bit-resolution, and temperature readings updated on each page refresh or after any user action that generated a new request.\n\n\nDesign and Testing Methodology\nA full-duplex SPI driver was developed using CMSIS. Since only a single SPI peripheral was required, chip-select management was simple and implemented using a dedicated GPIO pin.\nThe DS1722 must be configured before use by writing the appropriate control byte to register 0x80. A single-byte write involved sending the write address followed by the configuration byte over the SDI line. For single-byte reads, the MCU first wrote the read address (e.g., 0x01 or 0x02) to the sensor, then clocked out the data returned on the SDO line. The sensor was operated in one-shot conversion mode, so a read produced a fresh measurement each time.\nEvery SPI access—read or write—was wrapped with chip-select assertion and deassertion using a GPIO pin.\nTemperature reads required combining the MSB and LSB registers, where MSB stored the signed integer portion of the temperature (0x02) and LSB stored 4 bits of fractional data at 12-bit resolution (0x01). The DS1722 outputs temperature in signed two’s complement form. The MSB was right-shifted by 8 bits to isolate the integer portion, while the fractional bits were extracted from the LSB and multiplied by 0.0625. These values were added, cast to a float, and printed to the webpage.\nNegative temperature readings were validated by manually generating two’s-complement register values and confirming that the conversion logic produced the correct negative result.\n\n\nTechnical Documentation\nUART communication used GPIO Port A pins for TX and RX. To avoid conflicts between protocols, GPIO Port B was dedicated entirely to SPI (SCK, COPI, CIPO, chip-select).\nTo validate that SPI writes and reads were functioning, the DS1722 configuration register was written and then read back. A logic analyzer trace is shown below.\n\n\n\nFigure 0: SPI Transaction\n\n\nThe figure shows a write to and read of the configuration register on the COPI line. Write: Byte 0 is Config Address, Byte 1 is Config Data. Read: Byte 2 is read address, Byte 3 is returned Config Data (on the CIPO line). The returned byte correctly matched the value written earlier, confirming proper SPI operation.\nTemperature conversion required combining integer and fractional parts from the MSB and LSB registers. At 12-bit resolution:\nThe LSB represents fractions of 0.0625 degrees.\nThe MSB contains the signed integer temperature.\nThese components were combined and formatted into a decimal string for webpage display. To validate handling of negative values, synthetic MSB/LSB combinations corresponding to negative temperatures were constructed. When provided to the conversion code, these correctly produced negative decimal values.\n\n\nSchematic\nThe circuit below shows the full hardware implementation. A low-pass filter was added to the CIPO line to mitigate observed clock-coupling noise.\n\n\n\nFigure 1: Schematic\n\n\n\n\nResults and Discussion\nThis project successfully demonstrated SPI and UART communication, dynamic webpage generation, user adjustable resolution settings, and real-time temperature reporting through an IoT interface.\n\n\nConclusion\nThis lab produced a robust IoT device that integrated SPI, UART, and webserver functionality. The temperature sensor, MCU, WiFi module, and browser interface communicated seamlessly, demonstrating a complete end-to-end embedded system. The design was responsive, accurate, and easy to extend with additional controls or sensors.\n\n\nAI Prototype Summary\nI asked Gemini the prompt: I’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.\nThe LLM’s response, as well as my evaluation of the response, can be found here"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "Lab 5: Interrupts\n\nIntroduction\nIn this lab, hardware interrupts were configured on the STM32L432KC to capture all transitions from a quadrature encoder and accurately report the angular velocity of a motor. A DC motor with an attached quadrature (Hall-effect) encoder was powered and wired to the MCU’s GPIO pins. Interrupts were enabled and configured via register programming and an interrupt service routine (ISR) written in C. The interrupt inputs were decoded using a scheme that accounts for rotation direction and potential debouncing or jitter (as described in the STM32L4 reference manual), producing a signed pulse count from the encoder channels. The decoded pulse count was sampled and reset every 100 ms, yielding a velocity estimate at 10 Hz.\n\n\nDesign and Testing Methodology\nWork began with a review of quadrature encoder operation to determine how best to detect direction and maximize measurement resolution. To obtain the most precise velocity estimate, the design detects encoder pulses on both rising and falling edges of both channels A and B, i.e., four edges per mechanical cycle. With the implemented configurations, the Nested Vector Interrupt Controller (NVIC) redirects any encoder edge to the appropriate ISR by saving the program counter and loading the ISR address into the PC. The ISRs themselves are intentionally short, only setting a flag and then returning. The main loop in main.c detects these flags, reads both GPIO pins, and performs the decoding and accumulation of pulses. The decoding logic is inspired by the TIM2 Encoder Interface Mode documented in the STM32L4 reference manual. From there, the velocity is calculated following the equation:\n\\[\nVelocity =\n\\frac{pulses * time}{1000*no.edges*PPR}\n\\]\nAs time is reported in milliseconds, the factor of time/1000 component converts to seconds in the denominator. The sampling interval is 100ms and the encoder has a PPER of 408 Pulses Per Revolution. The code is written in a modular way such that switching to a report frequency of 1 Hz is simple and easy.\n\n\nTechnical Documentation\nThe basis for encoding of detected pulses was taken from the STM32L4xxxx Reference manual. The diagram is shown below.\n\n\n\nFigure 0: TIM2 Encoder Interface Chart (Figure 280 from Reference Manual)\n\n\nEach current and previous value was recorded, and the resulting contribution to the total number of pulses derived. To do so, the following two tables were written out.\n\nPrevious and Current Encoder Values\n\n\n\n\n\n\nFigure 1a: Oscilloscope Trace using Interrupt Method\n\n\n\n\n\n\n\nFigure 1b: Converted to Decimal\n\n\n\n\n\nThese detailed processing was executed through a case statement in C.\nTo validate the implementation, the encoder pulse frequency was measured on an oscilloscope. The corresponding motor velocity was computed by hand from the measured frequency and compared to the velocity computed and displayed via the MCU in SEGGER. The results matched within the expected tolerance.\n\n\n\nFigure 2: Velocity Calculations\n\n\n\n\n\nInterrupt Diagram\nThe below diagram illustrates the main steps of the program and different function calls that execute with the enabled interrupts.\n\n\n\nFigure 3: Interrupt Flowchart\n\n\n\n\nSchematic\nThe below schematic illustrates the simple setup for this design.\n\n\n\nFigure 4: Schematic\n\n\n\n\nResults and Discussion\nThis project successfully demonstrated the responsiveness and accuracy achievable with an interrupt-based interface to a quadrature encoder.\nTo quantify the benefit of interrupts, a second version of the code was implemented using polling: the GPIO pins were periodically sampled in software with a 200 ms delay. The two approaches were compared on an oscilloscope:\n\nPolling Oscilloscope Traces\n\n\n\n\n\n\nFigure 5a: Oscilloscope Trace using Polling Method\n\n\n\n\n\n\n\nFigure 5b: Zoomed in\n\n\n\n\n\n\n\nInterrupt Oscilloscope Traces\n\n\n\n\n\n\nFigure 6a: Oscilloscope Trace using Interrupt Method\n\n\n\n\n\n\n\nFigure 6b: Zoomed in\n\n\n\n\n\nWith the polling approach (200 ms delay), the MCU missed a large fraction of the encoder pulses. As a result, the velocity estimate was significantly underestimated, especially at higher motor speeds. With the interrupt-based approach, both the rising and falling edges of each encoder pulse were captured. The measured latency from an encoder edge to the “acknowledge” toggle was approximately 40 uS for the interrupt approach. Therefore, the maximum frequency of pulses that the encoder can report is 24.5 kHz. Using the polling approach, my encoder delays 200ms, so the maximum frequency of pulses is 5 Hz.\n\n\n\nConclusion\nThis design successfully implemented a quadrature encoder interface on the STM32L432KC using external interrupts. The reported velocity is precise for several reasons:\n\nThe system responds quickly to edges due to the interrupt-based design.\nBoth channels and both edges are used, providing high effective resolution.\nThe 10 Hz update rate strikes a good balance between responsiveness and stability.\nVelocity is computed with sufficient precision to capture small changes in speed.\n\nTogether, these choices yielded an accurate measurement of motor angular velocity and highlighted the advantages of interrupts over simple polling in embedded systems.\n\n\nAI Prototype Summary\nI prompted ChatGPT5 with the following: “Write me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?”\nThe LLM’s response, as well as my evaluation of the response, can be found here"
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "Lab 3: Keypad Scanner\nSOURCE CODE\n\nIntroduction\nIn this lab, a design was implemented on the UPduino v3.1 FPGA to scan a 4×4 matrix keypad and display a continuous stream of hexadecimal key presses on an HDSP-521A dual seven-segment LED display. Because of the limited number of FPGA pins, the design time-multiplexes the two digits. The lab addressed the challenges of handling asynchronous user inputs from the keypad and mitigating mechanical switch debouncing.\n\n\nDesign and Testing Methodology\nTo address these challenges, the design was separated into a Datapath and a Control Unit. The Datapath manages inputs, outputs, and intermediate storage and operations on signals. The Control Unit is a finite state machine (FSM) that coordinates the flow between abstract states, sending and receiving control signals to and from the Datapath.\nAdditional combinational logic encodes the relationships between the keypad’s columns and rows. The on-board iCE40 UltraPlus HSOSC high-speed oscillator was configured to generate a 12 MHz clock. This clock drives the main logic, and is also divided down to 60 Hz for the display time-multiplexing. At 60 Hz, the human eye no longer perceives individual refresh events, which prevents visible flicker.\n\n\nTechnical Documentation\n\nVerilog\nAs introduced above, the design is structured around a Controller (FSM) and a Datapath. The FSM is responsible solely for control signals and state transitions; it is implemented as a Moore machine, where outputs depend only on the current state.\n\n\n\nFigure 0: General Inspiration of Lab 3 Design\n\n\nMy FSM is composed of six states:\n    State 0 (Scan)\n    State 1 (Synch)\n    State 2 (Debounce) \n    State 3 (Checking)\n    State 4 (Send)\n    State 5 (Release)\nState transitions proceed as follows:\n    0 → S1 when a row detects an input\n    S1 → S2 when the synchronizer asserts done\n    S2 → S3 when the debouncer asserts done\n    S3 → S4 if the same key is still pressed; otherwise S3 → S0\n    S4 → S5 unconditionally\n    S5 → S0 once the key is released\nThe Finite State Machine can be seen in the figure below.\n\n\n\nFigure 1: FSM for Lab 3 Design\n\n\nThe output and next state logic is outlined in the table below.\n\n\n\nFigure 2: Output and Next State Logic\n\n\nThe Datapath modules implement the operations required to advance the logic under control of the FSM:\n\nscancounter\n\nRepresents the four keypad columns as a 2-bit value. On each rising clock edge (when enabled), it increments through the four column codes, effectively sweeping the active column. It supports enable and reset control signals.\n\n\n\nsynchronizer\n\nConsists of two flip-flops used to synchronize asynchronous row inputs to the system clock. It has enable and reset inputs and asserts a done signal exactly when synchronization completes. Conceptually, it has two internal modes: “actively synchronizing” and “synchronization done.”\n\n\n\ndebouncer\n\nImplements a counter that increments on each rising edge of the 12 MHz clock while enabled. When disabled, the counter resets to zero. After 600,000 clock cycles, representing 50 ms, the module asserts a done signal, indicating that the input has remained stable long enough to be considered debounced. Like the synchronizer, it effectively has two modes: “actively counting” and “idle.”\n\n\n\nseg_ff\n\nA flip-flop based module that, when enabled, updates the right-hand digit with the most recent key press and shifts the previous value to the left-hand digit. This ensures that the most recent hex digit appears on the right, and the previous digit on the left. When disabled, the segments are turned off. It supports enable and reset.\n\n\n\n\nBreadboard\nThe HDSP-521A requires more current than the FPGA can source directly, so two 2N3906 PNP transistors were used to drive the digit anodes. Each segment cathode is connected through a 330 Ω resistor to the FPGA, chosen to provide approximately 3 mA of segment current over the effective drop:\n\n\n\nFigure 3: Resistor Calculation\n\n\nA 460 Ω resistor is placed between each transistor base and the corresponding GPIO pin to limit the base current to under 5 mA, as required by the device datasheet.\nThe priority encoder converts the 4-bit hex values into the appropriate seven-segment patterns, which are mapped to the HDSP-521A input pins.\nThe keypad has eight pins (four rows and four columns), wired as follows from Pin 0 to Pin 8: {R0, C0, R3, R1, R2, C1, C2, C3}, where Rx denotes a row and Cx denotes a column. The columns are driven active-high by FPGA GPIO pins. The rows are read by FPGA inputs and tied to 100 kΩ pull-down resistors to prevent floating values.\n\n\n\nBlock Diagram\nThe top-level module is lab3_ih with the following interface: * Inputs reset – from the development board inputrows – from the keypad row lines * Outputs cols – to the keypad column drivers segmentOut – to the shared segment cathodes anodeZeroOut – to the base of transistor 0 (digit 0) anodeOneOut – to the base of transistor 1 (digit 1)\nlab3_ih instantiates nine submodules:\n\nhf_osc – high-speed oscillator primitive\nclock_div – divides 12 MHz down to 60 Hz for display multiplexing\nFSM – control unit implementing the six-state machine\nDataPath – encapsulating the datapath logic\ncolrowseg0, colrowseg1 – column/row to segment encoders for each digit\nsegments0, segments1 – seven-segment decoders for the two digits\nanodeselect – selects which digit’s anode is active based on the multiplexing clock\n\nInside DataPath.sv, five additional submodules are instantiated:\n\nscancounter – cycles through keypad columns\ncombcol – encodes the active column\nsynchronizer – synchronizes row inputs to the clock domain\ndebouncer – debounces mechanical switching\nseg_ff – updates and stores the two displayed hex digits\n\n\n\n\nFigure 5: Block Diagram\n\n\n\n\nSchematic\nThe schematic shows the physical wiring on the breadboard: Corresponding cathodes from the two digits of the dual display share the same node (e.g., digit 1 segment A and digit 2 segment A). Each shared node is connected in series with a 330 Ω current-limiting resistor to a GPIO pin. The on-board LEDs use 1 kΩ resistors for current limiting. For each PNP transistor, the emitter is tied to 3.3 V, the collector drives the common anode of the segment anodes, and the base is in series with a 460 Ω resistor from a GPIO pin. Keypad columns are wired directly from FPGA GPIO outputs. Keypad rows are wired to FPGA GPIO inputs and additionally connected to 100 kΩ pull-down resistors.\n\n\n\nFigure 6: Schematic\n\n\n\n\nResults and Discussion\nThis design met the intended objectives. All module-level testbenches passed. The dual seven-segment display correctly showed the hex digits corresponding to keypad inputs. The system did not lock or get confused when an invalid, asynchronous, or mechanically-bounced input was punched in. The two digits were clearly illuminated and visually distinct, with no noticeable flicker.\n\n\nTestbench Simulation\nA testbench simulation was produced for every module in the design.\n\ntb_lab3_ih:\nThe testbench for lab3_ih can be found here. Seven different button presses were tested and proven to output the correct value, including corner cases, such as what happens when there is a double press, or what happens when second press is asserted while the first press is still held. The testbench also verified that the column scan stops when expected, and that the row/column encoding matches the intended key. Correct segment outputs and anode control were observed. No errors occurred.\n\n\n\nFigure 7: Testbench Simulation Results for lab3_ih\n\n\n\n\ntb_DataPath:\nThe testbench for the DataPath module can be found here. This testbench exercises different combinations of control signals from the FSM and verifies the timing and coherence of all DataPath submodules. It includes both typical use cases and corner cases (such as invalid inputs). No errors occurred.\n\n\n\nFigure 8: Testbench Simulation Results for DataPath\n\n\n\n\ntb_FSM:\nThe testbench for the FSM module can be found here. All combinations of FSM inputs were tested. The testbench tracked both the current state and next state to ensure they matched the expected transitions. Two full cycles through the FSM were simulated. No errors occurred.\n\n\n\nFigure 9: Testbench Simulation Results for FSM\n\n\n\n\ntb_CombCol:\nThe testbench for the CombCol module can be found here. This testbench tested all different possible combinations of inputs into the CombCol module- a simple encoder. No errors occured.\n\n\n\nFigure 10: Testbench Simulation Results for CombCol\n\n\n\n\ntb_clock_div:\nThe testbench for the clock divider module can be found here. A test oscillator was produced that ticked every 100000 time stamps, where two time stamps represent a full clock cycle. The test oscillator was compared to that produced by the clock_div module when fed in the testbench clock signal. Both oscillators can be seen to rise and fall simulataneously. The HSOSC produces a 12 MHz clock. The clock divider module has been shown to divide the input clock signal by 200000. 12 MHz/200000 = 60 Hz, which is the targeted frequency switching between displays. No errors occured.\n\n\n\nFigure 11: Testbench Simulation Results for clock_div\n\n\n\n\ntb_anodeselect:\nThe testbench for the anodeselect module can be found here. The test verifies that the correct segment output and segment anode are sent off the FPGA at the correct multiplexed timestamp. The test verifies that the two segments are never sent out at the same time. No errors occured.\n\n\n\nFigure 12: Testbench Simulation Results for anodeselect\n\n\n\n\ntb_colrowseg:\nThe testbench for the colrowseg module can be found here. The test asserts all possible inputs for this combinational module. No errors occured.\n\n\n\nFigure 13: Testbench Simulation Results for colrowseg\n\n\n\n\ntb_debouncer:\nThe testbench for the debouncer module can be found here. The testbench verifies the enable behavior of the debouncer and confirms that 600,000 clock cycles are required before the done signal asserts. At 12 MHz, this corresponds to 50 ms. No errors occurred.\n\n\n\nFigure 14: Testbench Simulation Results for debouncer\n\n\n\n\ntb_scancounter:\nThe testbench for the scancounter module can be found here. This testbench verifies that the scanning of columns cycles through columns and equal and even amount. Correct response to the enable signal was proven. No errors occured.\n\n\n\nFigure 15: Testbench Simulation Results for scancounter\n\n\n\n\ntb_seg_ff:\nThe testbench for the seg_ff module can be found here. A variety of different test cases were tested against the seg_ff module. Different row and column values were tested, including invalid ones, producing segment0 and segment1 signals. Correct response to the enable signal was proven. No errors occured.\n\n\n\nFigure 16: Testbench Simulation Results for seg_ff\n\n\n\n\ntb_synchronizer:\nThe testbench for the synchronizer module can be found here. This testbench confirms that, after two clock cycles, the asynchronous input is correctly synchronized to the clock domain. It also verifies the behavior of the enable input and the timing of the done signal. No errors occurred.\n\n\n\nFigure 17: Testbench Simulation Results for synchronizer\n\n\n\n\n\nConclusion\n\n\n\nFigure 18: Scanner in Action\n\n\nThis design successfully scanned a 4×4 keypad and drove a dual seven-segment display using time-multiplexed outputs. It handled asynchronous inputs and mechanical switch bounce without lockup or misinterpretation, and the chosen components and operating points provided strong, consistent illumination. The architecture—separating FSM control from a structured Datapath—resulted in a modular design that was straightforward to test and verify.\n\n\nAI Prototype Summary\nI provided the LLM three different prompts for this lab to see how it would perform depending on the content of the prompts.\nThe LLM’s response, as well as my evaluation of the response, can be found here"
  },
  {
    "objectID": "labs/ai/ai.html",
    "href": "labs/ai/ai.html",
    "title": "AI Prototypes for E155 Labs",
    "section": "",
    "text": "The prompt that I provided the LLM was: “Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”\nIn response, I received:\n// Blink an LED at ~2 Hz using the iCE40UP5K internal HFOSC.\n// Toolchains: Lattice Radiant/iCEcube2 or open-source (yosys/nextpnr-ice40).\n\nmodule up5k_led_blink_2hz (\n    output logic led_o   // drive your LED pin (active-high assumed)\n);\n\nlogic clk_12mhz;\n\nSB_HFOSC u_hfosc (\n    .CLKHFEN (1'b1),   // enable output (assert after 100 µs PU time)\n    .CLKHFPU (1'b1),   // power-up oscillator\n    .CLKHF   (clk_12mhz)\n);\n\nlocalparam int unsigned F_CLK_HZ = 12_000_000;\nlocalparam int unsigned F_BLINK_HZ = 2;\nlocalparam int unsigned TICKS_PER_TOGGLE = F_CLK_HZ / (2 * F_BLINK_HZ);\n\nlocalparam int COUNTER_W = $clog2(TICKS_PER_TOGGLE);\nlogic [COUNTER_W-1:0] tick_cnt /* synthesis preserve */;\n\nalways_ff @(posedge clk_12mhz) begin\n    if (tick_cnt == TICKS_PER_TOGGLE-1) begin\n        tick_cnt &lt;= '0;\n        led_o    &lt;= ~led_o;       // toggle at 2 Hz\n    end else begin\n        tick_cnt &lt;= tick_cnt + 1;\n    end\nend\n\ninitial led_o = 1'b0;\n\nendmodule\nWhen I attempted to synthesize this design, I thrown the error “instantiating unknown module SB_HFSOSC. VERI-1063”. I typed the error message back into the LLM, and it corrected itself by instantiating the module “SB_HFOSC”. The LLM had falsely named the Lattice iCE40/UP5K primitive of the on-board FPGA.\nI would overall rate the quality of the output poorly. I used ChatGPT 5 for this task, and would have expected it to not make such a basic and obvious mistake. The prompt asked to produce a very simple design, so I found it surprising that the LLM’s output didn’t synthesize on the first try. I also found the mistake surprising, because there should be a correlation between “iCE40/UP5K” and “SB_HFOSC”, rather than “SB_HFSOSC” in the data that the chatbot used to create its answer.\nOtherwise, the logic that the LLM created made sense, and the chatbot attempted to use local parameters and calculations to arrive at values necessary for the clock division. This makes the design modular."
  },
  {
    "objectID": "labs/ai/ai.html#ai-prototype-lab-1",
    "href": "labs/ai/ai.html#ai-prototype-lab-1",
    "title": "AI Prototypes for E155 Labs",
    "section": "",
    "text": "The prompt that I provided the LLM was: “Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”\nIn response, I received:\n// Blink an LED at ~2 Hz using the iCE40UP5K internal HFOSC.\n// Toolchains: Lattice Radiant/iCEcube2 or open-source (yosys/nextpnr-ice40).\n\nmodule up5k_led_blink_2hz (\n    output logic led_o   // drive your LED pin (active-high assumed)\n);\n\nlogic clk_12mhz;\n\nSB_HFOSC u_hfosc (\n    .CLKHFEN (1'b1),   // enable output (assert after 100 µs PU time)\n    .CLKHFPU (1'b1),   // power-up oscillator\n    .CLKHF   (clk_12mhz)\n);\n\nlocalparam int unsigned F_CLK_HZ = 12_000_000;\nlocalparam int unsigned F_BLINK_HZ = 2;\nlocalparam int unsigned TICKS_PER_TOGGLE = F_CLK_HZ / (2 * F_BLINK_HZ);\n\nlocalparam int COUNTER_W = $clog2(TICKS_PER_TOGGLE);\nlogic [COUNTER_W-1:0] tick_cnt /* synthesis preserve */;\n\nalways_ff @(posedge clk_12mhz) begin\n    if (tick_cnt == TICKS_PER_TOGGLE-1) begin\n        tick_cnt &lt;= '0;\n        led_o    &lt;= ~led_o;       // toggle at 2 Hz\n    end else begin\n        tick_cnt &lt;= tick_cnt + 1;\n    end\nend\n\ninitial led_o = 1'b0;\n\nendmodule\nWhen I attempted to synthesize this design, I thrown the error “instantiating unknown module SB_HFSOSC. VERI-1063”. I typed the error message back into the LLM, and it corrected itself by instantiating the module “SB_HFOSC”. The LLM had falsely named the Lattice iCE40/UP5K primitive of the on-board FPGA.\nI would overall rate the quality of the output poorly. I used ChatGPT 5 for this task, and would have expected it to not make such a basic and obvious mistake. The prompt asked to produce a very simple design, so I found it surprising that the LLM’s output didn’t synthesize on the first try. I also found the mistake surprising, because there should be a correlation between “iCE40/UP5K” and “SB_HFOSC”, rather than “SB_HFSOSC” in the data that the chatbot used to create its answer.\nOtherwise, the logic that the LLM created made sense, and the chatbot attempted to use local parameters and calculations to arrive at values necessary for the clock division. This makes the design modular."
  },
  {
    "objectID": "labs/ai/ai.html#ai-prototype-lab-2",
    "href": "labs/ai/ai.html#ai-prototype-lab-2",
    "title": "AI Prototypes for E155 Labs",
    "section": "AI Prototype Lab 2",
    "text": "AI Prototype Lab 2\nThe prompt that I provided the LLM was: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.” In return, I recieved the following design that did not synthesize:\n// Time Multiplexed Seven Segment Display Controller\n// This module uses a single seven segment decoder to drive two displays\n\nmodule seven_seg_mux (\n    input  logic        clk,\n    input  logic        reset_n,\n    input  logic [3:0]  digit0_in,    // First 4-bit input\n    input  logic [3:0]  digit1_in,    // Second 4-bit input\n    output logic [6:0]  seg0_out,     // Seven segment outputs for display 0\n    output logic [6:0]  seg1_out,     // Seven segment outputs for display 1\n    output logic        digit0_enable, // Enable signal for display 0\n    output logic        digit1_enable  // Enable signal for display 1\n);\n\n    // Internal signals\n    logic [3:0] mux_input;\n    logic [6:0] decoder_output;\n    logic       mux_select;\n    logic       slow_clk;\n\n    // Instantiate oscillator for timing\n    oscillator u_osc (\n        .clk(clk),\n        .reset_n(reset_n),\n        .slow_clk(slow_clk)\n    );\n\n    // Generate multiplexer select signal\n    always_ff @(posedge slow_clk or negedge reset_n) begin\n        if (!reset_n)\n            mux_select &lt;= 1'b0;\n        else\n            mux_select &lt;= ~mux_select;\n    end\n\n    // Input multiplexer\n    always_comb begin\n        case (mux_select)\n            1'b0: mux_input = digit0_in;\n            1'b1: mux_input = digit1_in;\n        endcase\n    end\n\n    // Instantiate seven segment decoder\n    seven_seg_decoder u_decoder (\n        .bin_in(mux_input),\n        .seg_out(decoder_output)\n    );\n\n    // Output demultiplexer and enable generation\n    always_comb begin\n        case (mux_select)\n            1'b0: begin\n                seg0_out = decoder_output;\n                seg1_out = 7'b1111111;  // All segments off (common anode)\n                digit0_enable = 1'b0;   // Active low enable\n                digit1_enable = 1'b1;   // Disabled\n            end\n            1'b1: begin\n                seg0_out = 7'b1111111;  // All segments off\n                seg1_out = decoder_output;\n                digit0_enable = 1'b1;   // Disabled\n                digit1_enable = 1'b0;   // Active low enable\n            end\n        endcase\n    end\n\nendmodule\n\n// Seven Segment Decoder Module\n// Converts 4-bit binary input to seven segment display pattern\n// Common anode configuration (active low outputs)\nmodule seven_seg_decoder (\n    input  logic [3:0] bin_in,\n    output logic [6:0] seg_out\n);\n\n    // Segment mapping: seg_out = {g, f, e, d, c, b, a}\n    // Common anode: 0 = segment on, 1 = segment off\n    always_comb begin\n        case (bin_in)\n            4'h0: seg_out = 7'b1000000; // 0\n            4'h1: seg_out = 7'b1111001; // 1\n            4'h2: seg_out = 7'b0100100; // 2\n            4'h3: seg_out = 7'b0110000; // 3\n            4'h4: seg_out = 7'b0011001; // 4\n            4'h5: seg_out = 7'b0010010; // 5\n            4'h6: seg_out = 7'b0000010; // 6\n            4'h7: seg_out = 7'b1111000; // 7\n            4'h8: seg_out = 7'b0000000; // 8\n            4'h9: seg_out = 7'b0010000; // 9\n            4'hA: seg_out = 7'b0001000; // A\n            4'hB: seg_out = 7'b0000011; // b\n            4'hC: seg_out = 7'b1000110; // C\n            4'hD: seg_out = 7'b0100001; // d\n            4'hE: seg_out = 7'b0000110; // E\n            4'hF: seg_out = 7'b0001110; // F\n        endcase\n    end\n\nendmodule\n\n// Simple Oscillator Module\n// Generates a slower clock for multiplexing\nmodule oscillator (\n    input  logic clk,\n    input  logic reset_n,\n    output logic slow_clk\n);\n\n    parameter DIVIDE_BY = 100000; // Adjust for desired refresh rate\n    logic [$clog2(DIVIDE_BY)-1:0] counter;\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            counter &lt;= '0;\n            slow_clk &lt;= 1'b0;\n        end else begin\n            if (counter == DIVIDE_BY - 1) begin\n                counter &lt;= '0;\n                slow_clk &lt;= ~slow_clk;\n            end else begin\n                counter &lt;= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\n// Testbench for verification\nmodule seven_seg_mux_tb;\n\n    logic        clk;\n    logic        reset_n;\n    logic [3:0]  digit0_in;\n    logic [3:0]  digit1_in;\n    logic [6:0]  seg0_out;\n    logic [6:0]  seg1_out;\n    logic        digit0_enable;\n    logic        digit1_enable;\n\n    // Instantiate DUT\n    seven_seg_mux dut (\n        .clk(clk),\n        .reset_n(reset_n),\n        .digit0_in(digit0_in),\n        .digit1_in(digit1_in),\n        .seg0_out(seg0_out),\n        .seg1_out(seg1_out),\n        .digit0_enable(digit0_enable),\n        .digit1_enable(digit1_enable)\n    );\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    // Test stimulus\n    initial begin\n        reset_n = 0;\n        digit0_in = 4'h0;\n        digit1_in = 4'h0;\n\n        #100 reset_n = 1;\n\n        // Test different digit combinations\n        #1000 digit0_in = 4'h3; digit1_in = 4'h7;\n        #2000 digit0_in = 4'hA; digit1_in = 4'hF;\n        #2000 digit0_in = 4'h5; digit1_in = 4'h2;\n\n        #5000 $finish;\n    end\n\n    // Monitor outputs\n    initial begin\n        $monitor(\"Time=%0t, digit0_in=%h, digit1_in=%h, seg0=%b, seg1=%b, en0=%b, en1=%b\", \n                $time, digit0_in, digit1_in, seg0_out, seg1_out, digit0_enable, digit1_enable);\n    end\n\nendmodule\nNext, I asked the LLM to: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.” and attached my Lab 1 files. I received the following design that, again, did not synthesize.\n// Isabella Hottenrott's segments module\n// segments.sv\n// Module containing Verilog code for Seven-segment display mapping\nmodule segments(input logic [3:0] digit,\n                output logic [6:0] segs);\n\nalways_comb\ncase(digit)\n    0:  segs = 7'b000_0001; //0\n    1:  segs = 7'b100_1111; //1\n    2:  segs = 7'b001_0010; //2\n    3:  segs = 7'b000_0110; //3\n    4:  segs = 7'b100_1100; //4\n    5:  segs = 7'b010_0100; //5\n    6:  segs = 7'b010_0000; //6\n    7:  segs = 7'b000_1111; //7\n    8:  segs = 7'b000_0000; //8\n    9:  segs = 7'b000_1100; // 9\n    10: segs = 7'b000_1000; //a\n    11: segs = 7'b110_0000; //b\n    12: segs = 7'b011_0001; //c\n    13: segs = 7'b100_0010; //d\n    14: segs = 7'b011_0000; //e\n    15: segs = 7'b011_1000; //f\n    default:    segs = 7'b111_1111;\nendcase\nendmodule\n\n// Simple oscillator module for timing control\nmodule oscillator(input logic clk,\n              input logic reset,\n              output logic slow_clk);\n\nparameter DIVIDE_RATIO = 50000; // Adjust for desired refresh rate\nlogic [$clog2(DIVIDE_RATIO)-1:0] counter;\n\nalways_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n        counter &lt;= 0;\n        slow_clk &lt;= 0;\n    end else begin\n        if (counter == DIVIDE_RATIO - 1) begin\n            counter &lt;= 0;\n            slow_clk &lt;= ~slow_clk;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\nend\nendmodule\n\nmodule seven_seg_time_mux(\n    input logic clk,\n    input logic reset,\n    input logic [3:0] digit0,    // First 4-bit input\n    input logic [3:0] digit1,    // Second 4-bit input\n    output logic [6:0] segs0,    // Seven segment outputs for display 0\n    output logic [6:0] segs1     // Seven segment outputs for display 1\n);\n\n// Internal signals\nlogic [3:0] mux_digit;       // Multiplexed input to decoder\nlogic [6:0] decoder_segs;    // Output from segments decoder\nlogic mux_select;            // Select signal for multiplexing\nlogic slow_clk;              // Slower clock for multiplexing\n\n// Instantiate oscillator for timing control\noscillator timing_gen (\n    .clk(clk),\n    .reset(reset),\n    .slow_clk(slow_clk)\n);\n\n// Generate multiplexer select signal (toggles between displays)\nalways_ff @(posedge slow_clk or posedge reset) begin\n    if (reset)\n        mux_select &lt;= 1'b0;\n    else\n        mux_select &lt;= ~mux_select;\nend\n\n// Input multiplexer - select which digit to decode\nalways_comb begin\n    case (mux_select)\n        1'b0: mux_digit = digit0;\n        1'b1: mux_digit = digit1;\n        default: mux_digit = digit0;\n    endcase\nend\n\n// Instantiate Isabella's segments decoder\nsegments decoder (\n    .digit(mux_digit),\n    .segs(decoder_segs)\n);\n\n// Output demultiplexer - route decoder output to appropriate display\n// When a display is not selected, turn off all segments (common anode = all high)\nalways_comb begin\n    case (mux_select)\n        1'b0: begin\n            segs0 = decoder_segs;    // Display digit0\n            segs1 = 7'b111_1111;     // Turn off display 1\n        end\n        1'b1: begin\n            segs0 = 7'b111_1111;     // Turn off display 0\n            segs1 = decoder_segs;    // Display digit1\n        end\n        default: begin\n            segs0 = 7'b111_1111;\n            segs1 = 7'b111_1111;\n        end\n    endcase\nend\nendmodule\nlogic clk;\nlogic reset;\nlogic [3:0] digit0;\nlogic [3:0] digit1;\nlogic [6:0] segs0;\nlogic [6:0] segs1;\n\n// Instantiate the Device Under Test (DUT)\nseven_seg_time_mux dut (\n    .clk(clk),\n    .reset(reset),\n    .digit0(digit0),\n    .digit1(digit1),\n    .segs0(segs0),\n    .segs1(segs1)\n);\n\n// Clock generation (50MHz system clock)\ninitial begin\n    clk = 0;\n    forever #10 clk = ~clk; // 20ns period = 50MHz\nend\n\n// Test stimulus\ninitial begin\n    // Initialize signals\n    reset = 1;\n    digit0 = 4'h0;\n    digit1 = 4'h0;\n    \n    // Release reset\n    #100 reset = 0;\n    \n    // Test case 1: Display 3 and 7\n    #1000 digit0 = 4'h3; digit1 = 4'h7;\n    \n    // Test case 2: Display A and F (hex)\n    #5000 digit0 = 4'hA; digit1 = 4'hF;\n    \n    // Test case 3: Display 5 and 2\n    #5000 digit0 = 4'h5; digit1 = 4'h2;\n    \n    // Test case 4: Display 8 and 1\n    #5000 digit0 = 4'h8; digit1 = 4'h1;\n    \n    // Finish simulation\n    #10000 $finish;\nend\n\n// Monitor key signals\ninitial begin\n    $monitor(\"Time=%0t, digit0=%h, digit1=%h, segs0=%b, segs1=%b\", \n             $time, digit0, digit1, segs0, segs1);\nend\n\n// Generate VCD file for waveform viewing\ninitial begin\n    $dumpfile(\"seven_seg_mux.vcd\");\n    $dumpvars(0, seven_seg_time_mux_tb);\nend\nendmodule\nBoth designs ran into the issue that the “loop count limit [of the clock] exceeded forever never breaks”. This occured because both LLM outputs created associated testbenches. I tried to take out this forever statement, and make the clock tick similarly to my own testbenches. However, when I did this, I received a “Synthesize Design Completed, Lattice Synthesis Engine Failed” error."
  },
  {
    "objectID": "labs/ai/ai.html#ai-prototype-lab-3",
    "href": "labs/ai/ai.html#ai-prototype-lab-3",
    "title": "AI Prototypes for E155 Labs",
    "section": "AI Prototype Lab 3",
    "text": "AI Prototype Lab 3\nThe first prompt that I provided the LLM was a monolithic prompts:\n    \"Target device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\n\n    Write synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement:\n\n    A clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator.\n    A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release.\n    A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness.\n    Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.\" \nIn return, I recieved the following design linked here that synthesized. This verilog produced a design with four FSM states. The instantiation of these states can be seen below. There was no FSM module specifically, and state transitions were scattered throughout the module. \nOtherwise, the commented logic provided by the LLM followed a path that made sense. The encodings for the segments were correct.\nNext, I prompted the LLM in a modular manner such that it would decompose FSMs. The first of these prompts was:\n    \"Target device: Lattice iCE40 UP5K FPGA.\n\n    Overall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display.\n\n    Current Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior:\n\n    When a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse.\n    While any key remains pressed, do not accept additional keys.\n    Only after keys are released should a subsequent press be recognized.\n    This should handle debouncing of the keys.\n    Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here.\"\nIn return, I recieved the following design linked here that synthesized.\nThe second modular prompt was: “Target device: Lattice iCE40 UP5K FPGA.\n    Write a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior:\n\n    Iterate columns at a suitable scan rate derived from the divided clock and sample rows.\n    When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed.\n    Provide a boolean signal indicating whether any key is currently pressed.\n    Use clean state encoding and synchronous logic; avoid combinational feedback and latches.\"\nIn return, I recieved the following design linked here that synthesized.\nThe design decoded the columns and rows in a case statement, verbosely breaking down every column and row possibility. Immediately, the row and column combinations were converted into the hex value that was pressed.\n\n\n\nFigure 19: AI Proto Bii Breakdownof Columns and Rows\n\n\nThe final of the modular prompts was: “Target device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source.\n    Write a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements:\n\n    Update the displayed digits only when a new key is registered.\n    Ensure equal apparent brightness and no visible flicker.\n    Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs.\n    Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.\"\nIn return, I recieved the following design linked here.\n\n\n\nFigure 20: AI Proto Biii Unsynthesizable Clock\n\n\nThis was the first of the designs returned by the LLM that did not synthesize. Claude attempted to import the wrong High Frequency Oscillator, as shown in the image above."
  },
  {
    "objectID": "labs/ai/ai.html#ai-prototype-lab-4",
    "href": "labs/ai/ai.html#ai-prototype-lab-4",
    "title": "AI Prototypes for E155 Labs",
    "section": "AI Prototype Lab 4",
    "text": "AI Prototype Lab 4\nI prompted the following LLM with the question:\nWhat timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\nIt responded:\nTIM2 (32-bit general-purpose) — easiest and most flexible choice. It has multiple channel outputs you can route to GPIO pins (e.g., PA0/PA5/PA15 → TIM2_CH1 (AF1), PB3 → TIM2_CH2 (AF1), etc.).  ￼\nTIM1 / TIM15–17 (16-bit) — also fine for PWM; TIM1 is “advanced” (needs MOE bit set) but you don’t need advanced features for simple tones. Device includes 1× advanced, 2× GP16, 1× GP32 per datasheet.  ￼\nLPTIM1 / LPTIM2 (low-power timers) — great if you want the signal to keep running in Stop modes or be clocked from LSE/LSI, and they have an OUT pin you can map (e.g., PA4/PA8 → LPTIM2_OUT (AF14)). For simple “always-on” PWM they work well too.  ￼\n\nBest simple choice for GPIO: TIM2 — 32-bit (so huge range/resolution), plentiful pin options (AF1 on several pins), and zero “advanced timer” gotchas.\nOverall, the datasheet got the explicitly-mentioned functionalities of the onboard timer right. For the specific application, it was wrong in deciding that 32 bits would be necessary. It did not include configurations to the RCC that need to be made for the Timers. It also forgot to add anything about registers or calculations for the actual clock division. The LLM also pointed toward the low-power timers. This is not unreasonable, because it wasn’t given any information on how long the timers would be active vs idle. After providing the LLM with the Reference Manual, it reaffirmed the decision to use Timer 2. Overall, I think going through the reference manual on my own is still a better use of time than taking the LLM output and debugging. I was a bit surprised about this, because I feel that there is enough online documentation for the LLM to output a more detailed response."
  },
  {
    "objectID": "labs/ai/ai.html#ai-prototype-lab-5",
    "href": "labs/ai/ai.html#ai-prototype-lab-5",
    "title": "AI Prototypes for E155 Labs",
    "section": "AI Prototype Lab 5",
    "text": "AI Prototype Lab 5\nI prompted ChatGPT5 with the following: “Write me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?”\nIn response, it provided me with the following:\n    \"// Globals\n    static volatile int32_t encoder_count = 0;\n    static volatile uint8_t prev_state = 0;\n\n    // Call this during init (after HAL_Init and clocks).\n    static void Encoder_EXTI_Init(void) {\n        __HAL_RCC_GPIOA_CLK_ENABLE();\n\n        gi.Mode  = GPIO_MODE_IT_RISING_FALLING;  // fire on both edges\n        gi.Pull  = GPIO_PULLUP;                  // or GPIO_NOPULL if you have externals\n        gi.Speed = GPIO_SPEED_FREQ_LOW;\n\n        // Using PA0 (A) and PA1 (B). Change to whatever pins you chose.\n        gi.Pin = GPIO_PIN_0 | GPIO_PIN_1;\n        HAL_GPIO_Init(GPIOA, &gi);\n\n        // Read initial state\n        uint8_t a = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) ? 1 : 0;\n        uint8_t b = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1) ? 1 : 0;\n        prev_state = (a &lt;&lt; 1) | b;\n\n        // Enable EXTI lines NVIC (EXTI0 for PA0, EXTI1 for PA1)\n        HAL_NVIC_SetPriority(EXTI0_IRQn, 5, 0);\n        HAL_NVIC_EnableIRQ(EXTI0_IRQn);\n\n        HAL_NVIC_SetPriority(EXTI1_IRQn, 5, 0);\n        HAL_NVIC_EnableIRQ(EXTI1_IRQn);\n    } \n    \n    // Returns +1, -1, or 0 based on transition\n        static inline int8_t quad_step(uint8_t prev, uint8_t next) {\n            // Index  (prev&lt;&lt;2)|next, values: 0, +1, -1, etc.\n            static const int8_t lut[16] = {\n                0,  +1,  -1,   0,\n                -1,  0,   0,  +1,\n                +1,  0,   0,  -1,\n                0,  -1,  +1,   0\n            };\n            return lut[(prev &lt;&lt; 2) | next];\n        }\n\n        static inline void Encoder_EXTI_Service(void) {\n            uint8_t a = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) ? 1 : 0;\n            uint8_t b = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1) ? 1 : 0;\n            uint8_t next = (a &lt;&lt; 1) | b;\n\n            int8_t d = quad_step(prev_state, next);\n            prev_state = next;\n            encoder_count += d;\n        }\n\n        // IRQs (CubeMX names)\n        void EXTI0_IRQHandler(void) {\n            HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);\n        }\n        void EXTI1_IRQHandler(void) {\n            HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_1);\n        }\n\n        void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {\n            if (GPIO_Pin == GPIO_PIN_0 || GPIO_Pin == GPIO_PIN_1) {\n                Encoder_EXTI_Service();\n            }\n        }\"\nThis code did not compile. I pasted some of the errors in, and the chatpot responded that it forgot to add in the line:\n    \"GPIO_InitTypeDef gi = {0};\"\n    \nThe definition of gi is necessary; without it, there is no valid gi object for the code to configure, so those member accesses would always fail. This addition still didnt compile.\nThe next issue was that the chatbot had not included the appropriate HAL GPIO header file. In order for both GPIO_InitTypeDef and the various HAL GPIO functions and macros (such as HAL_GPIO_Init, HAL_GPIO_ReadPin, and the GPIO_PIN_x definitions) to be recognized, the code needs an explicit include, for example:\n    \"#include stm32l4xx_hal_gpio.h\"\nI was a bit surprised by these omissions in the generated code, since they are fairly fundamental to getting a basic STM32 HAL example to compile. In hindsight, though, I suspect the chatbot simply assumed that I already had the standard STM32 HAL headers included elsewhere in my project and was only trying to illustrate the interrupt-handling and quadrature-decoding logic itself, rather than providing a completely drop-in, self-contained code snippet."
  },
  {
    "objectID": "labs/ai/ai.html#ai-prototype-lab-6",
    "href": "labs/ai/ai.html#ai-prototype-lab-6",
    "title": "AI Prototypes for E155 Labs",
    "section": "AI Prototype Lab 6",
    "text": "AI Prototype Lab 6\nI asked Gemini the prompt: I’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.\nIt responded:\n    &lt;!DOCTYPE html&gt;\n    &lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n        &lt;title&gt;Temperature Sensor Portal&lt;/title&gt;\n        \n        &lt;style&gt;\n            /* --- General Styling --- */\n            body {\n                font-family: 'Arial', sans-serif;\n                background-color: #f0f2f5;\n                display: flex;\n                justify-content: center;\n                align-items: flex-start;\n                min-height: 100vh;\n                margin: 0;\n                padding-top: 50px;\n            }\n\n            .container {\n                background-color: #ffffff;\n                padding: 30px;\n                border-radius: 12px;\n                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n                width: 100%;\n                max-width: 400px;\n                text-align: center;\n            }\n\n            h1 {\n                color: #333;\n                margin-bottom: 30px;\n                font-size: 1.8em;\n                border-bottom: 2px solid #eee;\n                padding-bottom: 10px;\n            }\n            \n            /* --- Temperature Display --- */\n            #temperature-display {\n                font-size: 4em;\n                font-weight: bold;\n                color: #d9534f; /* Warm color for temperature */\n                margin-bottom: 20px;\n            }\n\n            .unit {\n                font-size: 0.5em;\n                vertical-align: top;\n                display: inline-block;\n                margin-left: 5px;\n            }\n\n            /* --- Control Section --- */\n            .control-group {\n                margin-top: 25px;\n                padding: 15px;\n                border: 1px solid #ddd;\n                border-radius: 8px;\n                text-align: left;\n            }\n            \n            .control-group h3 {\n                margin-top: 0;\n                color: #555;\n                font-size: 1.1em;\n                border-bottom: 1px solid #eee;\n                padding-bottom: 8px;\n                margin-bottom: 15px;\n            }\n\n            .control-item {\n                display: flex;\n                justify-content: space-between;\n                align-items: center;\n                margin-bottom: 15px;\n            }\n\n            .control-item:last-child {\n                margin-bottom: 0;\n            }\n\n            /* --- LED Control Button --- */\n            #led-button {\n                padding: 10px 20px;\n                border: none;\n                border-radius: 5px;\n                cursor: pointer;\n                font-weight: bold;\n                transition: background-color 0.3s, box-shadow 0.3s;\n            }\n\n            .led-on {\n                background-color: #5cb85c; /* Green */\n                color: white;\n                box-shadow: 0 2px 4px rgba(92, 184, 92, 0.4);\n            }\n\n            .led-off {\n                background-color: #f0ad4e; /* Orange */\n                color: white;\n                box-shadow: 0 2px 4px rgba(240, 173, 78, 0.4);\n            }\n\n            #led-button:hover {\n                opacity: 0.9;\n            }\n\n            /* --- Precision Control --- */\n            #precision-select {\n                padding: 8px;\n                border-radius: 5px;\n                border: 1px solid #ccc;\n                background-color: #f9f9f9;\n            }\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n\n    &lt;div class=\"container\"&gt;\n        &lt;h1&gt;Web Sensor Interface&lt;/h1&gt;\n\n        &lt;div class=\"data-display\"&gt;\n            &lt;h2&gt;Current Temperature&lt;/h2&gt;\n            &lt;div id=\"temperature-display\"&gt;\n                24&lt;span class=\"unit\"&gt;.50°C&lt;/span&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;hr&gt;\n        \n        &lt;div class=\"control-group\"&gt;\n            &lt;h3&gt;Device Controls&lt;/h3&gt;\n\n            &lt;div class=\"control-item\"&gt;\n                &lt;span&gt;**LED Status:**&lt;/span&gt;\n                &lt;button id=\"led-button\" class=\"led-off\"&gt;Turn ON&lt;/button&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"control-item\"&gt;\n                &lt;span&gt;**Readout Precision:**&lt;/span&gt;\n                &lt;select id=\"precision-select\" onchange=\"updateTemperature(currentTemp)\"&gt;\n                    &lt;option value=\"0\"&gt;0 Decimal (25°C)&lt;/option&gt;\n                    &lt;option value=\"1\"&gt;1 Decimal (24.5°C)&lt;/option&gt;\n                    &lt;option value=\"2\" selected&gt;2 Decimals (24.50°C)&lt;/option&gt;\n                    &lt;option value=\"3\"&gt;3 Decimals (24.500°C)&lt;/option&gt;\n                &lt;/select&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n        // --- Global State ---\n        let isLedOn = false;\n        let currentTemp = 24.505; // Placeholder for the full temperature value\n\n        // --- DOM Elements ---\n        const tempDisplay = document.getElementById('temperature-display');\n        const ledButton = document.getElementById('led-button');\n        const precisionSelect = document.getElementById('precision-select');\n\n        // --- Functions ---\n\n        /**\n        * Toggles the LED state (simulated).\n        * In a real application, this would send an AJAX/Fetch request to your sensor's backend.\n        */\n        function toggleLed() {\n            isLedOn = !isLedOn;\n            if (isLedOn) {\n                ledButton.textContent = 'Turn OFF';\n                ledButton.classList.remove('led-off');\n                ledButton.classList.add('led-on');\n                console.log(\"LED turned ON. (Simulated backend call)\");\n                // Real code: fetch('/api/led/on');\n            } else {\n                ledButton.textContent = 'Turn ON';\n                ledButton.classList.remove('led-on');\n                ledButton.classList.add('led-off');\n                console.log(\"LED turned OFF. (Simulated backend call)\");\n                // Real code: fetch('/api/led/off');\n            }\n        }\n        \n        /**\n        * Updates the temperature display based on the selected precision.\n        * @param {number} temp - The raw temperature value.\n        */\n        function updateTemperature(temp) {\n            const precision = parseInt(precisionSelect.value);\n            const parts = temp.toFixed(precision).split('.');\n            \n            // Handle case where precision is 0 (no decimal part)\n            const integerPart = parts[0];\n            const decimalPart = parts.length &gt; 1 ? '.' + parts[1] : '';\n\n            tempDisplay.innerHTML = `${integerPart}&lt;span class=\"unit\"&gt;${decimalPart}°C&lt;/span&gt;`;\n        }\n\n        /**\n        * Simulates fetching new sensor data and updates the display.\n        * In a real application, this would run periodically via setInterval or WebSockets.\n        */\n        function fetchNewTemperature() {\n            // In a real app, you'd use fetch:\n            // fetch('/api/temperature').then(res =&gt; res.json()).then(data =&gt; { currentTemp = data.temp; updateTemperature(currentTemp); });\n\n            // For this example, let's simulate a minor temp change:\n            currentTemp = 24.505 + (Math.random() - 0.5) / 10; // Small random fluctuation\n            updateTemperature(currentTemp);\n        }\n\n\n        // --- Event Listeners and Initial Setup ---\n        \n        // 1. LED Button\n        ledButton.addEventListener('click', toggleLed);\n\n        // 2. Initial Temperature Display\n        updateTemperature(currentTemp);\n\n        // 3. Simulated Live Update (fetches new temp every 5 seconds)\n        setInterval(fetchNewTemperature, 5000); // Poll every 5 seconds (adjust as needed)\n\n    &lt;/script&gt;\n\n    &lt;/body&gt;\n    &lt;/html&gt;\nNext, I asked: Write me a C function to carry out a SPI transaction to retrieve a temperature reading from a DS1722 sensor. Make use of CMSIS libraries for the STM32L432KC.\nIt responded:\n    #include \"ds1722.h\"\n    #include &lt;stdint.h&gt;\n\n    /**\n    * @brief Performs an SPI transaction to read the temperature from the DS1722 sensor.\n    * * The DS1722 expects a 1-byte read command (0x01) followed by 2 bytes of data \n    * which contain the 16-bit two's complement temperature value. The LSB is 1/128 °C.\n    * * @param None\n    * @return The temperature reading in degrees Celsius (float).\n    */\n    float DS1722_ReadTemperature(void)\n    {\n        // The transaction requires 1 byte for the command (0x01) followed by 2 bytes\n        // of dummy data to clock out the 16-bit temperature from the sensor.\n        uint8_t tx_buffer[3] = {DS1722_CMD_READ_TEMP, 0xFF, 0xFF};\n        uint8_t rx_buffer[3] = {0};\n        \n        int16_t raw_temperature = 0;\n        float temperature_celsius = 0.0f;\n\n        // 1. Activate Chip Select (CS low)\n        HAL_GPIO_WritePin(DS1722_CS_GPIO_PORT, DS1722_CS_PIN, GPIO_PIN_RESET);\n\n        // 2. Transmit the command byte and simultaneously receive the data bytes.\n        // The total transfer length is 3 bytes (Command + MSB Data + LSB Data).\n        HAL_StatusTypeDef status = HAL_SPI_TransmitReceive(\n            &DS1722_hspi, \n            tx_buffer, \n            rx_buffer, \n            3, \n            HAL_MAX_DELAY\n        );\n\n        // 3. Deactivate Chip Select (CS high)\n        HAL_GPIO_WritePin(DS1722_CS_GPIO_PORT, DS1722_CS_PIN, GPIO_PIN_SET);\n\n        // Check for successful transmission\n        if (status != HAL_OK)\n        {\n            // Handle error: return a distinct error value or log the issue\n            // For simplicity, we return a very low value.\n            return -999.0f; \n        }\n\n        /* * The temperature data is returned in rx_buffer[1] (MSB) and rx_buffer[2] (LSB).\n        * The MSB is received first.\n        * Raw data format: [S S S S S S S S | D D D D D D D D]\n        * MSB (rx_buffer[1]) holds the high 8 bits.\n        * LSB (rx_buffer[2]) holds the low 8 bits.\n        * The LSB is bit D7 (1/128 degree Celsius).\n        */\n        \n        // Combine the 2 received bytes into a 16-bit signed integer (Two's complement)\n        raw_temperature = (int16_t)((rx_buffer[1] &lt;&lt; 8) | rx_buffer[2]);\n\n        // 4. Convert the raw two's complement value to Celsius.\n        // The resolution is 1/128 °C (0.0078125 °C) per LSB.\n        temperature_celsius = (float)raw_temperature / 128.0f;\n\n        return temperature_celsius;\n    }\nThe HTML production was successful and impressive. However, the C code did the wrong temperature conversion, multiplying the LSB by 1/128 instead of 1/16. The C function it produced for reading from the DS1722 sensor looked structurally correct at first glance: it wrapped the SPI transaction properly, used the HAL/CMSIS conventions correctly, handled chip-select sequencing, and even included basic error handling. However, once I compared the code’s data interpretation logic with the DS1722 datasheet, it became clear that the chatbot had misrepresented a core part of the temperature conversion formula. This highlights a general trend when using LLMs for embedded development: they are quite good at scaffolding boilerplate structure and recalling common HAL usage patterns, but any sensor-specific constants, timing rules, or register interpretations still need to be verified against the manufacturer documentation."
  },
  {
    "objectID": "posts/second-post.html",
    "href": "posts/second-post.html",
    "title": "Blog 1",
    "section": "",
    "text": "As of today, I have completed my first MicroPs lab. Overall, I did not think that the tasks were too challenging. I have PCB assembly experience from my summer internship, and very quickly understood what was needed to be done on the FPGA. That said, I ended up spending around twenty hours working. I did not anticipate some issues, such as missing components and the fact that the software took a very long time to load. However, I learned many lessons about what I will not allow myself to do in the future.\nLesson 1- I was quite absent-minded when configuring my project. I accidentally created a Verilog file instead of a SystemVerilog file, which caused syntax errors and took me around an hour to discover. I also gave my files/modules undescriptive names twice in a row. In order to rename the files, while making sure the whole project/file tree stayed consistent, I had to start a new project. This involved a lot of time wasted waiting for Radiant to power up. I would also often close the Programmer after being thrown the J-Link issue, even though this wasn’t necessary. This meant that I would have to wait for the Programmer to open almost every time I tried to reprogram the FPGA, which always took a while.\nLesson 2- Having my check off on Thursday meant that I was working at a slower and less efficient pace than my peers in lab, because I didn’t have the stress of a near upcoming assignment. I think I spent more time in lab than was necessary, not doing efficient work. As a result, the two nights before my Thursday check-in were longer nights for me.\nI do not feel positively toward how I managed my time and brain resources on this first lab. However, I am foremost taking this as a learning experience. I am happy this happened to me now and made me realize I have to get into shape before more difficult labs come along."
  },
  {
    "objectID": "project/midwaycheckin.html",
    "href": "project/midwaycheckin.html",
    "title": "Midway Project",
    "section": "",
    "text": "The main objective of this project is to build a rock-paper scissors game, where a human player plays against the computer. An LCD, driven by the FPGA, will display the computer’s play (rock, paper, or scissors). The player’s move will be picked up by a series of 5 LiDAR sensors, and the computer’s move will be generated on the MCU. The below diagram depicts the general system that our design intends to follow.\n\n\n\nFigure 0: General Block Diagram\n\n\n\n\n\nThe circuit for the VL53L0X sensors has been built and tested, as well as a rudimentary version (3 LEDs) of the user interface has been built. The overall system is depicted below in a schematic. The sensors are connected to the same SCL and SDA lines, which are both connected to a 4.7kΩ pull-up resistor. Each sensor is also connected to its own XSHUT line, which allows individual programming of each device. The sensors need 2.8V, which is provided by a 3.3V voltage applied to the VCC pin, which is then regulated by an on-board voltage regulator. The MCU has been connected to the FPGA using 3 SPI lines– chip select (CS), system clock (SCK), and MOSI. The MISO line has been omitted, as the SPI between the FPGA and MCU is mono-directional for this project’s purpose. The FPGA also takes in a physical RESET signal from a pushbutton. The output, which currently acts as a placeholder for the screen, consists of 3 LEDs.\n\n\n\nFigure 1: Current Hardware Design Schematic\n\n\nAt the moment, only three VL53L0X sensors are functioning. Sensors #2 and #4 are able to take on a new address and can be communicated with, however they consistently return the value 8191, which represents an error code. Using components of the API that we were able to adapt for our STM, we were unable to diagnose the issue. Our next step will be to speak with the dysfunctional sensors through an Arduino, such that we can use the official, unlimited API from the Adafruit library. If we remain unable to diagnose the issue, we believe we can safely assume that the sensors are broken, as they were inexpensive and ordered off of amazon, and many online reviews report that they are bad.\n\n\n\nAt this stage, both the FPGA and MCU have functioning firmware. The MCU successfully communicates with all VL53L0X sensors over I2C and incorporates the VL53L0X API. As a result, sensor initialization is possible, and accurate distance measurements are reported through the MCU. The firmware also includes a gesture-interpretation routine that converts the ToF readings into the player’s rock, paper, or scissors choice. A random number generator selects the computer’s move, and a comparison routine determines the outcome of the game using standard rock-paper-scissors rules. To report the findings of the game, both the player’s choice and the computer’s choice, along with the final result, are printed through the MCU’s debug interface. The outcome of the round is then transmitted to the FPGA over an SPI link. For now, the MCU encodes the win, lose, and draw status in the upper three bits of the SPI byte. Thai format will later be expanded to include additional information about gameplay state and timing. A captured SPI waveform demonstrating communication from the MCU to the FPGA is shown below. The trace represents a “draw” game status being communicated, as the second of the top three bits is HIGH.\n\n\n\nFigure 2: SPI trace from the MCU to the FPGA\n\n\nRTL for the FPGA to receive an SPI transaction from the MCU has been written. Additionally, the FPGA has been programmed to interpret the SPI transaction and display whether a win, lose, or draw has occurred via three LEDs.\n\n\n\nFigure 3: Current block diagram for the FPGA\n\n\nThe SPI reception and output of the LEDs were tested with a testbench, shown below. All test vectors passed.\n\n\n\nFigure 4: SPI Testbench Results\n\n\nThe FPGA drives three LEDS: The top one represents that the COMPUTER has WON. The middle one represents that there has been a DRAW, and the bottom LED represents that the PLAYER has WON. The FPGA also has a reset button to reset the LED status to turn them all off.\n\n\n\nThe remaining work can be broken down into four categories. The most important aspect is driving the display, as that will ensure the entire game can function, and then additional verification is needed to meet all of our specifications.\nVL53L0X Sensors\n•   Validate distance-measurement accuracy\n•   Verify robust gesture recognition across diverse hand sizes and poses\nFPGA\n•   Implement full game logic and state machine\n•   Drive the display pipeline (dot-matrix or LCD)\n•   Integrate ROM for precomputed patterns and assets\nDisplay\n•   Design and implement all required UI screens (moves, countdowns, scoring, etc.)\nPhysical Design\n•   Prototype and refine mechanical components\n•   Integrate the scanning platform with time-of-flight sensors\n⸻\nFirstly, we will focus on being able to drive our display, and then we will combine all of the various parts, debug, and ensure functionality. The display and game logic take priority, and will be completed before Thanksgiving break. The final touches will be completed during and after the break.\nAppendix: The code for the design at this point in time can be found in our e155-final-project repository, on the WinLoseDraw Branch"
  },
  {
    "objectID": "project/midwaycheckin.html#introduction",
    "href": "project/midwaycheckin.html#introduction",
    "title": "Midway Project",
    "section": "",
    "text": "The main objective of this project is to build a rock-paper scissors game, where a human player plays against the computer. An LCD, driven by the FPGA, will display the computer’s play (rock, paper, or scissors). The player’s move will be picked up by a series of 5 LiDAR sensors, and the computer’s move will be generated on the MCU. The below diagram depicts the general system that our design intends to follow.\n\n\n\nFigure 0: General Block Diagram"
  },
  {
    "objectID": "project/midwaycheckin.html#hardware-status",
    "href": "project/midwaycheckin.html#hardware-status",
    "title": "Midway Project",
    "section": "",
    "text": "The circuit for the VL53L0X sensors has been built and tested, as well as a rudimentary version (3 LEDs) of the user interface has been built. The overall system is depicted below in a schematic. The sensors are connected to the same SCL and SDA lines, which are both connected to a 4.7kΩ pull-up resistor. Each sensor is also connected to its own XSHUT line, which allows individual programming of each device. The sensors need 2.8V, which is provided by a 3.3V voltage applied to the VCC pin, which is then regulated by an on-board voltage regulator. The MCU has been connected to the FPGA using 3 SPI lines– chip select (CS), system clock (SCK), and MOSI. The MISO line has been omitted, as the SPI between the FPGA and MCU is mono-directional for this project’s purpose. The FPGA also takes in a physical RESET signal from a pushbutton. The output, which currently acts as a placeholder for the screen, consists of 3 LEDs.\n\n\n\nFigure 1: Current Hardware Design Schematic\n\n\nAt the moment, only three VL53L0X sensors are functioning. Sensors #2 and #4 are able to take on a new address and can be communicated with, however they consistently return the value 8191, which represents an error code. Using components of the API that we were able to adapt for our STM, we were unable to diagnose the issue. Our next step will be to speak with the dysfunctional sensors through an Arduino, such that we can use the official, unlimited API from the Adafruit library. If we remain unable to diagnose the issue, we believe we can safely assume that the sensors are broken, as they were inexpensive and ordered off of amazon, and many online reviews report that they are bad."
  },
  {
    "objectID": "project/midwaycheckin.html#softwarefirmware-status",
    "href": "project/midwaycheckin.html#softwarefirmware-status",
    "title": "Midway Project",
    "section": "",
    "text": "At this stage, both the FPGA and MCU have functioning firmware. The MCU successfully communicates with all VL53L0X sensors over I2C and incorporates the VL53L0X API. As a result, sensor initialization is possible, and accurate distance measurements are reported through the MCU. The firmware also includes a gesture-interpretation routine that converts the ToF readings into the player’s rock, paper, or scissors choice. A random number generator selects the computer’s move, and a comparison routine determines the outcome of the game using standard rock-paper-scissors rules. To report the findings of the game, both the player’s choice and the computer’s choice, along with the final result, are printed through the MCU’s debug interface. The outcome of the round is then transmitted to the FPGA over an SPI link. For now, the MCU encodes the win, lose, and draw status in the upper three bits of the SPI byte. Thai format will later be expanded to include additional information about gameplay state and timing. A captured SPI waveform demonstrating communication from the MCU to the FPGA is shown below. The trace represents a “draw” game status being communicated, as the second of the top three bits is HIGH.\n\n\n\nFigure 2: SPI trace from the MCU to the FPGA\n\n\nRTL for the FPGA to receive an SPI transaction from the MCU has been written. Additionally, the FPGA has been programmed to interpret the SPI transaction and display whether a win, lose, or draw has occurred via three LEDs.\n\n\n\nFigure 3: Current block diagram for the FPGA\n\n\nThe SPI reception and output of the LEDs were tested with a testbench, shown below. All test vectors passed.\n\n\n\nFigure 4: SPI Testbench Results\n\n\nThe FPGA drives three LEDS: The top one represents that the COMPUTER has WON. The middle one represents that there has been a DRAW, and the bottom LED represents that the PLAYER has WON. The FPGA also has a reset button to reset the LED status to turn them all off."
  },
  {
    "objectID": "project/midwaycheckin.html#remaining-work-and-timeline",
    "href": "project/midwaycheckin.html#remaining-work-and-timeline",
    "title": "Midway Project",
    "section": "",
    "text": "The remaining work can be broken down into four categories. The most important aspect is driving the display, as that will ensure the entire game can function, and then additional verification is needed to meet all of our specifications.\nVL53L0X Sensors\n•   Validate distance-measurement accuracy\n•   Verify robust gesture recognition across diverse hand sizes and poses\nFPGA\n•   Implement full game logic and state machine\n•   Drive the display pipeline (dot-matrix or LCD)\n•   Integrate ROM for precomputed patterns and assets\nDisplay\n•   Design and implement all required UI screens (moves, countdowns, scoring, etc.)\nPhysical Design\n•   Prototype and refine mechanical components\n•   Integrate the scanning platform with time-of-flight sensors\n⸻\nFirstly, we will focus on being able to drive our display, and then we will combine all of the various parts, debug, and ensure functionality. The display and game logic take priority, and will be completed before Thanksgiving break. The final touches will be completed during and after the break.\nAppendix: The code for the design at this point in time can be found in our e155-final-project repository, on the WinLoseDraw Branch"
  },
  {
    "objectID": "project/projectproposal.html",
    "href": "project/projectproposal.html",
    "title": "Project Proposal",
    "section": "",
    "text": "Project Proposal\n\nProject Description & Overview\nThe main objective of this project is to build a rock-paper scissors game, where a human player plays against the computer. A LED Dot Matrix, driven by the FPGA, will display the computer’s play (rock, paper, or scissors), as well as any other pertinent information (score, countdown, etc). The player’s move will be picked up by a series of 5 LiDAR sensors. The five LiDAR sensors will be placed beneath the scanning platform and strategically positioned so that specific combinations of sensor activations correspond to particular game moves. The scanning platform will outline an area for players to position their hands, ensuring proper alignment and preventing misclassification of plays. Rock-paper-scissors provides three very distinct gestures Ensuring the LiDAR sensors work is the most crucial element (poses the highest risk) to the success of this project. The LiDARs are the main sensing mechanism that interfaces with the outside world, and their placement must be strategically optimized to consistently ensure that a player’s move is recognized. The design must ensure correct and consistent height classifications for the hand placements across a range of moves and player profiles. The design should also account for occasional missed reflections due to off-angle surfaces. Moreover, according to our trade study, the VL53L0X sensors can interfere with each other’s readings, requiring the design to time multiplex between the five sensors in retrieving the distance data.\n\n\nBlock Diagram\n\n\n\nFigure 0: Block Diagram\n\n\n\n\nSchedule and Division of Work\n\n\n\nFigure 1: Schedule\n\n\n\n\n\nFigure 2: Gantt Chart\n\n\nTo portion the work, we will first create a shared github so we always have access to our main body of work. We will each take a task, and update the exact task week-by-week. It is important that we both gain experience with the LED Dot Matrix and the LiDAR, to both have awareness of code development, but more insight is gained in the debugging stage, so that is where we will prioritize working together.\n\nFPGA Design Details\nTo meet the specifications, the FPGA will:\nShow the desired pattern, communicated from the MCU through SPI protocol\nNo flashing/flickering– produces a steady image of the desired pattern, or Start/Win/Lose screens\nDisplay pattern for the desired amount of time (starting at 1 second and decreasing to 100 ms) and the countdown within 2% of correct/desired intervals\nReceive and process a variety of signals from the MCU, including Start/Reset, Win, Lose, and Level # via an FSM implemented in HDL\nDesign fits on FPGA hardware\nIf the FPGA receives a START signal, it will display the initialization screen, until it receives an update from the MCU. The MCU, after 5s, will send a signal indicating that the first level has started and the sequence it should display. Then, the FPGA will display this pattern for a designated amount of time. Then, the FPGA will display a timer counting down, indicating the amount of time the player has to put the pieces in the puzzle. After, it will send a signal to the MCU indicating it has finished its operations. To actually drive the display, the FPGA will use 10 pins, and send out the appropriate signals. It will utilize an FSM to correctly sequence the control signals.\nFPGA Timing Calculations: Using the High Frequency Oscillator We want the FPGA to measure 5s, 1s, and multiples of 100µS to control the display. We will use the 12 MHz HSOSC clock and therefore require the following counters:\n\n\n\nFigure 3: FPGA Timing Calculations\n\n\n\n\nLCD Design Details\nThe Liquic Crystal Display component has a 20x2 display, and a built-in Sitronix ST7066U controller. It needs 10 pins from the FPGA. Nine of those pins are used to transmit the character to be displayed, the 10th pin is used as an enable, and the 11th is used for the RS (register select) pin . It also needs 5V to power the logic, and up to 13V to power the LCD itself.\n\n\n\nMCU Design Details\nTo meet the specifications, the MCU will: Implement the i2c protocol Read (time-multiplex) and verify the five LiDAR sensor inputs Turn only one LiDAR sensor on at a time LiDAR distance readings in within 8% of the true distance Only one pin used for i2c communication with all four sensors MCU timing reflects desired intervals The MCU will require 13 GPIO pins: 6 pins for LiDAR sensor XSHUT (one each), 1 pin for i2c communication with the LiDAR sensors, 4 pins for SPI communication with the FPGA, 1 pin for reset signal, 1 pin for PlayButton signal. Upon reset, the MCU will send a signal to the FPGA to display the “Start Game” display and send a reset signal to the FPGA. It will remain in a while loop until PlayButton is asserted. Upon PlayButton, the MCU will wait to receive a signal from the FPGA denoting that it should read the move the player asserted via LiDAR sensors, and then communicate the data collected to the FPGA. The game will continue until one party wins by achieving 3 wins.\nMCU Timing Calculations: For each sensor, we will follow the recommended 33 ms of reading time + 2 ms for extra buffer. The host will poll at 10 kHz for measurement status. With Sysclk = 80Mhz: PSC=79, ARR=99.\n\n\n\nFigure 4: MCU Timing Calculations\n\n\nMCU Distance Range Calculations: Using the recommended 33ms scan time while indoors with a white target, we are given that the standard deviation is 4%. Therefore, 95% of measurements will fall within ±8% of the true distance. We will account for this with the following margins.\n\n\n\nFigure 5: MCU Distance Margins\n\n\n\n\nTime of Flight Sensors\nThe Time-of-Flight (ToF) sensors are breakout boards housing the STM VL53L0X ToF IC. The sensors require 3.3V power and have a programmable i2c address, as well as an XSHUT (reset) pin. The sensors will be time multiplexed by active-low XSHUT signals, forcing only a single sensor to read at a time to prevent bus conflicts and IR interference. The sensors will follow the application schematic shown in Figure 3. of the user manual. The VL53L0X API will be downloaded and used to control and interface with the sensors.\n\n\nBill of Materials\n\n\n\nFigure 6: Bill of Materials\n\n\nHardware Specifications:\nSensors are fixed at bottom of the box\nMinimal light interference\nDoes not require recalibration between games\nGame box is aesthetically inoffensive and does break\nWithstands frequent user handling"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "E155 Course Website\nE155 Github Repository\nSTM32L432KC Documentation\nUpduino Documentation"
  },
  {
    "objectID": "resources.html#portfolio-resources",
    "href": "resources.html#portfolio-resources",
    "title": "Resources",
    "section": "",
    "text": "E155 Course Website\nE155 Github Repository\nSTM32L432KC Documentation\nUpduino Documentation"
  }
]