[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Isabella’s Blog Page\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBlog 1\n\n\nReflections on Lab 1\n\n\n\n\n\nSep 4, 2025\n\n\nBella Hottenrott\n\n\n\n\n\n\n\n\n\n\n\n\nBlog 0\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 28, 2025\n\n\nBella Hottenrott\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Bella Hottenrott is a senior Engineering major at Harvey Mudd College. Her background lies in electrical, computer, and controls engineering. Over the weekends, she and her friends like to go surfing, hiking, and exploring in LA. When she has time to herself, she is almost certainly listening to a podcast, on a run, or making herself a coffee."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Blog 0",
    "section": "",
    "text": "I am excited to take E155 this semester. I remember seeing the seniors going to lab for this class when I was a freshman. Now I am in my final year and feel I have a strong enough engineering background to take this course. I am excited to challenge myself. Most of all, I am excited to build the resilience and debugging skills that this course develops.\nI found Lab 0 relatively easy. It allowed me to reflect on the Git, Linux, and Quarto familiarity that I’ve gained over the past year. I am not sure that I would have been able to set up this portfolio a year ago."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "Lab 3: Keypad Scanner\n\nIntroduction\n\n\nDesign and Testing Methodology\n\n\nTechnical Documentation\n\n\nBlock Diagram\n\n\nSchematic\n\n\nResults and Discussion\n\n\nTestbench Simulation\n\n\nConclusion\n\n\nAI Prototype Summary"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "Lab 5: Interrupts\n\nIntroduction\n\n\nDesign and Testing Methodology\n\n\nTechnical Documentation\n\n\nBlock Diagram\n\n\nSchematic\n\n\nResults and Discussion\n\n\nTestbench Simulation\n\n\nConclusion\n\n\nAI Prototype Summary"
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "",
    "text": "Lab 7: The Advanced Encryption Standard\n\nIntroduction\n\n\nDesign and Testing Methodology\n\n\nTechnical Documentation\n\n\nBlock Diagram\n\n\nSchematic\n\n\nResults and Discussion\n\n\nTestbench Simulation\n\n\nConclusion\n\n\nAI Prototype Summary"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Lab 1: FPGA and MCU Setup and Testing\n\nIntroduction\nIn this lab, a design was implemented on the UPduino v3.1 FPGA to interface with and demonstrate the proper assembly of the E155 Development Board. This lab also exhibited the functionalities of the Dev Board’s LEDs, the FPGA’s on-board high-speed oscillator, and a Seven Segment Display.\n\n\nDesign and Testing Methodology\nThe iCE40 UltraPlus HSOSC primitive- an on-board high-speed oscillator- was used to generate a clock signal at 48 MHz.\nA separate clock divider module was created to divide the HSOSC signal to a frequency of 2.4 Hz using a counter that reset every 10,000 counts. This drove an external LED.\nLogic to control the other two on-board LEDs included a simple XOR gate and AND gate between two sets of switches.\nTo control the input to the Seven Segment Display, a priority encoder was used. The output signals were mapped to their respective pins on the input of the HDSP-511A Seven Segment Display. 3.3V were applied to the common anode of the display. To turn a segment ON, the respective GPIO pin was grounded, producing a 3.3V drop across the segment’s anode. The forward voltage of the segments’ diodes is 1.95V. The current flowing through the diode was chosen to be 1mA. Therefore the value of the current limiting resistor placed in series between the cathode and GPIO pin was 1 kΩ. Calculations for this component value can be found below.\n\n\n\nFigure 1: Calculations for the current-limiting resistor values\n\n\nTo turn a segment OFF, the respective GPIO pin was set to 3.3V, producing no voltage drop across the segment, therefore allowing no current to flow.\nTo test this design, all different combinations of the four input switches were tried out, ensuring that each produced the desired segment display and LED-illumination. In testing the frequency of the blinking LED, the number of flashes that occured within 10 seconds were counted. This number- 23 flashes- was divided by 10 to confirm a frequency of 2.4 Hz.\n\n\nTechnical Documentation\nThe source code for Lab 1 can be found in the following GitHub repository.\n\nBlock Diagram\n\n\n\nFigure 2: Block Diagram of the lab1_ih verilog design\n\n\nThe block diagram above illustrates the lab1_ih design. The top level module is called lab1_ih and takes the input s[3:0] and outputs led[2:0] and segs[6:0], communicating with the GPIO pins. Lab1_ih includes three submodules: the high-speed oscillator block (hf_osc), the seven segments priority encoder (segments), and the clock divider to 2.4 Hz (clock_div).\n\n\nSchematic\n\n\n\nFigure 3: Schematic of the Physical Circuit\n\n\nThe schematic above illustrates the physical layout on the breadboard. The diode cathodes from the seven segment display were connected in series with a 1 kΩ current-limiting resistor. Similarly, the on-board LEDs required 1 kΩ resistors to their limit current. Internal 100kΩ pull-up resistors were used to keep the active low SW7 from floating.\n\n\n\nResults and Discussion\nThis design met the intended objectives. All switches perform the intended logic, as can be demonstrated on the board by performing all switch combinations. A testbench simulation to verify the SystemVerilog design was not provided for this lab. This was a missing component of this project.\n\n\nConclusion\nThe design successfully blinked an external LED using the on-board high-speed oscillator. Doing so demonstrated that the development board was properly assembled. I spent a total of twenty hours working on this lab.\n\n\nAI Prototype Summary\nThe prompt that I provided the LLM was: “Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”\nIn response, it provided me with the following:\n// Blink an LED at ~2 Hz using the iCE40UP5K internal HFOSC.\n// Toolchains: Lattice Radiant/iCEcube2 or open-source (yosys/nextpnr-ice40).\n\nmodule up5k_led_blink_2hz (\n    output logic led_o   // drive your LED pin (active-high assumed)\n);\n\nlogic clk_12mhz;\n\nSB_HFOSC u_hfosc (\n    .CLKHFEN (1'b1),   // enable output (assert after 100 µs PU time)\n    .CLKHFPU (1'b1),   // power-up oscillator\n    .CLKHF   (clk_12mhz)\n);\n\nlocalparam int unsigned F_CLK_HZ = 12_000_000;\nlocalparam int unsigned F_BLINK_HZ = 2;\nlocalparam int unsigned TICKS_PER_TOGGLE = F_CLK_HZ / (2 * F_BLINK_HZ);\n\nlocalparam int COUNTER_W = $clog2(TICKS_PER_TOGGLE);\nlogic [COUNTER_W-1:0] tick_cnt /* synthesis preserve */;\n\nalways_ff @(posedge clk_12mhz) begin\n    if (tick_cnt == TICKS_PER_TOGGLE-1) begin\n        tick_cnt &lt;= '0;\n        led_o    &lt;= ~led_o;       // toggle at 2 Hz\n    end else begin\n        tick_cnt &lt;= tick_cnt + 1;\n    end\nend\n\ninitial led_o = 1'b0;\n\nendmodule\nWhen I attempted to synthesize this design, I thrown the error “instantiating unknown module SB_HFSOSC. VERI-1063”. I typed the error message back into the LLM, and it corrected itself by instantiating the module “SB_HFOSC”. The LLM had falsely named the Lattice iCE40/UP5K primitive of the on-board FPGA.\nI would overall rate the quality of the output poorly. I used ChatGPT 5 for this task, and would have expected it to not make such a basic and obvious mistake. The prompt asked to produce a very simple design, so I found it surprising that the LLM’s output didn’t synthesize on the first try. I also found the mistake surprising, because there should be a correlation between “iCE40/UP5K” and “SB_HFOSC”, rather than “SB_HFSOSC” in the data that the chatbot used to create its answer.\nOtherwise, the logic that the LLM created made sense, and the chatbot attempted to use local parameters and calculations to arrive at values necessary for the clock division. This makes the design modular."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface\n\nIntroduction\n\n\nDesign and Testing Methodology\n\n\nTechnical Documentation\n\n\nBlock Diagram\n\n\nSchematic\n\n\nResults and Discussion\n\n\nTestbench Simulation\n\n\nConclusion\n\n\nAI Prototype Summary"
  },
  {
    "objectID": "labs/labs.html",
    "href": "labs/labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1: FPGA and MCU Setup and Testing"
  },
  {
    "objectID": "labs/labs.html#lab-1",
    "href": "labs/labs.html#lab-1",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1: FPGA and MCU Setup and Testing"
  },
  {
    "objectID": "labs/labs.html#lab-2",
    "href": "labs/labs.html#lab-2",
    "title": "E155 Labs",
    "section": "Lab 2",
    "text": "Lab 2\nLab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs/labs.html#lab-3",
    "href": "labs/labs.html#lab-3",
    "title": "E155 Labs",
    "section": "Lab 3",
    "text": "Lab 3\nLab 3: Keypad Scanner"
  },
  {
    "objectID": "labs/labs.html#lab-4",
    "href": "labs/labs.html#lab-4",
    "title": "E155 Labs",
    "section": "Lab 4",
    "text": "Lab 4\nLab 4: Digital Audio"
  },
  {
    "objectID": "labs/labs.html#lab-5",
    "href": "labs/labs.html#lab-5",
    "title": "E155 Labs",
    "section": "Lab 5",
    "text": "Lab 5\nLab 5: Interrupts"
  },
  {
    "objectID": "labs/labs.html#lab-6",
    "href": "labs/labs.html#lab-6",
    "title": "E155 Labs",
    "section": "Lab 6",
    "text": "Lab 6\nLab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs/labs.html#lab-7",
    "href": "labs/labs.html#lab-7",
    "title": "E155 Labs",
    "section": "Lab 7",
    "text": "Lab 7\nLab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "Lab 2: Multiplexed 7-Segment Display\n\nIntroduction\nIn this lab, a design was implemented on the UPduino v3.1 FPGA that time-multiplexed between two seven-segment displays. The design utilized only one set of GPIO pins, and only one seven segment HDL module. The time multiplexing occured at a fast enough rate that switching between segments was not discernable to the human eye.\n\n\nDesign and Testing Methodology\nThe iCE40 UltraPlus HSOSC primitive was used to generate a clock signal, which was stepped down to a 60 Hz signal that the design was based on. At this frequency, the human eye can no longer percieve refresh rates. This frequency also ensured that bleeding did not occur between the two segments.\nAn 8-pin dip switch controls the HDSP-521A Dual Seven Segment Display, where the first four switches correspond to the first segment, and final four correspond to the second. When the internal clock is low, the input from the first four switches is selected, and when the clock is high, the input from the final four are selected.\nAt the same time, when the clock is low, a signal is sent to drive the common anode of the first segment. When the clock is high, a separate signal drives the common anode of the second segment.\nThe sum of the two hex values on the HDSP-521A Display is represented in binary on the on-board LEDs of the E155 Development Board. These diodes are in series with 1 kΩ resistors to limit current.\nThe Seven Segment Display module- a priority encoder- was used to convert the desired switch inputs into an output hex digit. The HDSP521A required a larger current draw than the FPGA can output, which was addressed by two 2N3906 PNP transistors. 330 Ω were placed at the cathodes of the diodes to ensure a 10mA current pull, over the (3.3 V - 0.25 Vce) = 3.05 V drop, through the segment when ON. Calculations for the current limiting resistor placed in series between the cathode and GPIO pin can be found below.\n\n\n\nFigure 0: Resistor Calculation\n\n\nA 460 Ω resistor was placed between the base of the PNP transistor and the GPIO pin to limit the current draw to under 5 mA, as specified by the datasheet. Calculations for this component value can be found below.\n\n\n\nFigure 1: Transistor Base Current Calculation\n\n\nTo control the input to the Seven Segment Display, a priority encoder was used. The output signals were mapped to their respective pins on the input of the HDSP-511A Seven Segment Display.\n\n\nTechnical Documentation\nThe source code for Lab 2 can be found in the following GitHub repository.\n\n\nBlock Diagram\n\n\n\nFigure 2: Block Diagram of the lab2_ih verilog design\n\n\nThe block diagram above illustrates the lab2_ih design. The top level module is called lab2_ih and takes in inputs: reset, sw1, and sw2. Lab2_ih outputs to five leds (led), a single set of GPIO pins for the dual seven segment (segs), to both transistors to illuminate the proper segment anode (anodeOne, anodeTwo), and to the two remaining on-board LEDs to keep them from floating (bottomLEDs). Lab1_ih includes five submodules: the high-speed oscillator block (hf_osc), the clock divider to 60 Hz (clock_div), the adder (adder), the seven segments priority encoder (segments), and the anode-selecting module (anodeselect).\n\n\nSchematic\nThe schematic above illustrates the physical layout on the breadboard. Corresponding diode cathodes from the seven segment displays were the same node (segment 1 A is the same node as segment 2 A, etc). These were connected in series with a 330 Ω current-limiting resistor to the GPIO pins. The on-board LEDs required 1 kΩ resistors to their limit current. The emitter of the transistor is powered by 3.3 V, while the collector goes straight to the segment anodes. The base of the PNP transistor is in series with a 460Ω resistor such that less than 5mA of current is drawn from the GPIO pin, which lies within specs. \n\n\nResults and Discussion\nThis design met the intended objectives. All switches correctly spoke with the board, the proper LED-sum combinations occured, and the Seven Segment Display shows two distinct hex values without any discernable flickering or bleeding.\n\n\nTestbench Simulation\nA testbench simulation was produced for every module in the design.\n\ntb_lab2_ih:\nThe testbench for lab2_ih can be found here. The high speed clock was commented out to run this simulation, and 10 known cases were tested against the design. No errors occured.\n\n\n\nFigure 4: Testbench Simulation Results for lab2_ih\n\n\n\n\ntb_segments:\nThe testbench for the segments module can be found here. All possible combinations of input switch values were tested. No errors occured.\n\n\n\nFigure 5: Testbench Simulation Results for segments\n\n\n\n\ntb_clock_div:\nThe testbench for the clock divider module can be found here. A test oscillator was produced that ticked every 800000 time stamps, where two time stamps represent a full clock cycle. The test oscillator was compared to that produced by the clock_div module when fed in the testbench clock signal. Both oscillators can be seen to rise and fall simulataneously. The HSOSC produces a 48 MHz clock. The clock divider module has been shown to divide the input clock signal by 800000. 48 MHz/800000 = 60 Hz, which is the targeted frequency switching between displays. No errors occured.\n\n\n\nFigure 6: Testbench Simulation Results for clock_div\n\n\n\n\ntb_anodeselect:\nThe testbench for the anodeselect module can be found here. The test verifies that the correct switch value is sent to the segment modules, as well as the corresponding correct anode, across 12 handwritten vectors. The test verifies that the two anodes are never HIGH at the same timestamp. No errors occured.\n\n\n\nFigure 7: Testbench Simulation Results for anodeselect\n\n\n\n\ntb_adder:\nThe testbench for the adder module can be found here. A system verilog function iterates through all possible switch combinations to verify all possible additions. No errors occured.\n\n\n\nFigure 8: Testbench Simulation Results for adder\n\n\n\n\n\nConclusion\nThis design design illuminated a Dual Seven Segment Display using a single segment module through the use of time-multiplexing. A transistor circuit and selected resistors were used to ensure that sufficient, but not excessive current, flows through components based on datasheet values. I spent a total of 18 hours on this lab.\n\n\nAI Prototype Summary\nThe prompt that I provided the LLM was: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.” In return, I recieved the following design that did not synthesize:\n// Time Multiplexed Seven Segment Display Controller\n// This module uses a single seven segment decoder to drive two displays\n\nmodule seven_seg_mux (\n    input  logic        clk,\n    input  logic        reset_n,\n    input  logic [3:0]  digit0_in,    // First 4-bit input\n    input  logic [3:0]  digit1_in,    // Second 4-bit input\n    output logic [6:0]  seg0_out,     // Seven segment outputs for display 0\n    output logic [6:0]  seg1_out,     // Seven segment outputs for display 1\n    output logic        digit0_enable, // Enable signal for display 0\n    output logic        digit1_enable  // Enable signal for display 1\n);\n\n    // Internal signals\n    logic [3:0] mux_input;\n    logic [6:0] decoder_output;\n    logic       mux_select;\n    logic       slow_clk;\n\n    // Instantiate oscillator for timing\n    oscillator u_osc (\n        .clk(clk),\n        .reset_n(reset_n),\n        .slow_clk(slow_clk)\n    );\n\n    // Generate multiplexer select signal\n    always_ff @(posedge slow_clk or negedge reset_n) begin\n        if (!reset_n)\n            mux_select &lt;= 1'b0;\n        else\n            mux_select &lt;= ~mux_select;\n    end\n\n    // Input multiplexer\n    always_comb begin\n        case (mux_select)\n            1'b0: mux_input = digit0_in;\n            1'b1: mux_input = digit1_in;\n        endcase\n    end\n\n    // Instantiate seven segment decoder\n    seven_seg_decoder u_decoder (\n        .bin_in(mux_input),\n        .seg_out(decoder_output)\n    );\n\n    // Output demultiplexer and enable generation\n    always_comb begin\n        case (mux_select)\n            1'b0: begin\n                seg0_out = decoder_output;\n                seg1_out = 7'b1111111;  // All segments off (common anode)\n                digit0_enable = 1'b0;   // Active low enable\n                digit1_enable = 1'b1;   // Disabled\n            end\n            1'b1: begin\n                seg0_out = 7'b1111111;  // All segments off\n                seg1_out = decoder_output;\n                digit0_enable = 1'b1;   // Disabled\n                digit1_enable = 1'b0;   // Active low enable\n            end\n        endcase\n    end\n\nendmodule\n\n// Seven Segment Decoder Module\n// Converts 4-bit binary input to seven segment display pattern\n// Common anode configuration (active low outputs)\nmodule seven_seg_decoder (\n    input  logic [3:0] bin_in,\n    output logic [6:0] seg_out\n);\n\n    // Segment mapping: seg_out = {g, f, e, d, c, b, a}\n    // Common anode: 0 = segment on, 1 = segment off\n    always_comb begin\n        case (bin_in)\n            4'h0: seg_out = 7'b1000000; // 0\n            4'h1: seg_out = 7'b1111001; // 1\n            4'h2: seg_out = 7'b0100100; // 2\n            4'h3: seg_out = 7'b0110000; // 3\n            4'h4: seg_out = 7'b0011001; // 4\n            4'h5: seg_out = 7'b0010010; // 5\n            4'h6: seg_out = 7'b0000010; // 6\n            4'h7: seg_out = 7'b1111000; // 7\n            4'h8: seg_out = 7'b0000000; // 8\n            4'h9: seg_out = 7'b0010000; // 9\n            4'hA: seg_out = 7'b0001000; // A\n            4'hB: seg_out = 7'b0000011; // b\n            4'hC: seg_out = 7'b1000110; // C\n            4'hD: seg_out = 7'b0100001; // d\n            4'hE: seg_out = 7'b0000110; // E\n            4'hF: seg_out = 7'b0001110; // F\n        endcase\n    end\n\nendmodule\n\n// Simple Oscillator Module\n// Generates a slower clock for multiplexing\nmodule oscillator (\n    input  logic clk,\n    input  logic reset_n,\n    output logic slow_clk\n);\n\n    parameter DIVIDE_BY = 100000; // Adjust for desired refresh rate\n    logic [$clog2(DIVIDE_BY)-1:0] counter;\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            counter &lt;= '0;\n            slow_clk &lt;= 1'b0;\n        end else begin\n            if (counter == DIVIDE_BY - 1) begin\n                counter &lt;= '0;\n                slow_clk &lt;= ~slow_clk;\n            end else begin\n                counter &lt;= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\n// Testbench for verification\nmodule seven_seg_mux_tb;\n\n    logic        clk;\n    logic        reset_n;\n    logic [3:0]  digit0_in;\n    logic [3:0]  digit1_in;\n    logic [6:0]  seg0_out;\n    logic [6:0]  seg1_out;\n    logic        digit0_enable;\n    logic        digit1_enable;\n\n    // Instantiate DUT\n    seven_seg_mux dut (\n        .clk(clk),\n        .reset_n(reset_n),\n        .digit0_in(digit0_in),\n        .digit1_in(digit1_in),\n        .seg0_out(seg0_out),\n        .seg1_out(seg1_out),\n        .digit0_enable(digit0_enable),\n        .digit1_enable(digit1_enable)\n    );\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    // Test stimulus\n    initial begin\n        reset_n = 0;\n        digit0_in = 4'h0;\n        digit1_in = 4'h0;\n\n        #100 reset_n = 1;\n\n        // Test different digit combinations\n        #1000 digit0_in = 4'h3; digit1_in = 4'h7;\n        #2000 digit0_in = 4'hA; digit1_in = 4'hF;\n        #2000 digit0_in = 4'h5; digit1_in = 4'h2;\n\n        #5000 $finish;\n    end\n\n    // Monitor outputs\n    initial begin\n        $monitor(\"Time=%0t, digit0_in=%h, digit1_in=%h, seg0=%b, seg1=%b, en0=%b, en1=%b\", \n                $time, digit0_in, digit1_in, seg0_out, seg1_out, digit0_enable, digit1_enable);\n    end\n\nendmodule\nNext, I asked the LLM to: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.” and attached my Lab 1 files. I received the following design that, again, did not synthesize.\n// Isabella Hottenrott's segments module\n// segments.sv\n// Module containing Verilog code for Seven-segment display mapping\nmodule segments(input logic [3:0] digit,\n                output logic [6:0] segs);\n\nalways_comb\ncase(digit)\n    0:  segs = 7'b000_0001; //0\n    1:  segs = 7'b100_1111; //1\n    2:  segs = 7'b001_0010; //2\n    3:  segs = 7'b000_0110; //3\n    4:  segs = 7'b100_1100; //4\n    5:  segs = 7'b010_0100; //5\n    6:  segs = 7'b010_0000; //6\n    7:  segs = 7'b000_1111; //7\n    8:  segs = 7'b000_0000; //8\n    9:  segs = 7'b000_1100; // 9\n    10: segs = 7'b000_1000; //a\n    11: segs = 7'b110_0000; //b\n    12: segs = 7'b011_0001; //c\n    13: segs = 7'b100_0010; //d\n    14: segs = 7'b011_0000; //e\n    15: segs = 7'b011_1000; //f\n    default:    segs = 7'b111_1111;\nendcase\nendmodule\n\n// Simple oscillator module for timing control\nmodule oscillator(input logic clk,\n              input logic reset,\n              output logic slow_clk);\n\nparameter DIVIDE_RATIO = 50000; // Adjust for desired refresh rate\nlogic [$clog2(DIVIDE_RATIO)-1:0] counter;\n\nalways_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n        counter &lt;= 0;\n        slow_clk &lt;= 0;\n    end else begin\n        if (counter == DIVIDE_RATIO - 1) begin\n            counter &lt;= 0;\n            slow_clk &lt;= ~slow_clk;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\nend\nendmodule\n\nmodule seven_seg_time_mux(\n    input logic clk,\n    input logic reset,\n    input logic [3:0] digit0,    // First 4-bit input\n    input logic [3:0] digit1,    // Second 4-bit input\n    output logic [6:0] segs0,    // Seven segment outputs for display 0\n    output logic [6:0] segs1     // Seven segment outputs for display 1\n);\n\n// Internal signals\nlogic [3:0] mux_digit;       // Multiplexed input to decoder\nlogic [6:0] decoder_segs;    // Output from segments decoder\nlogic mux_select;            // Select signal for multiplexing\nlogic slow_clk;              // Slower clock for multiplexing\n\n// Instantiate oscillator for timing control\noscillator timing_gen (\n    .clk(clk),\n    .reset(reset),\n    .slow_clk(slow_clk)\n);\n\n// Generate multiplexer select signal (toggles between displays)\nalways_ff @(posedge slow_clk or posedge reset) begin\n    if (reset)\n        mux_select &lt;= 1'b0;\n    else\n        mux_select &lt;= ~mux_select;\nend\n\n// Input multiplexer - select which digit to decode\nalways_comb begin\n    case (mux_select)\n        1'b0: mux_digit = digit0;\n        1'b1: mux_digit = digit1;\n        default: mux_digit = digit0;\n    endcase\nend\n\n// Instantiate Isabella's segments decoder\nsegments decoder (\n    .digit(mux_digit),\n    .segs(decoder_segs)\n);\n\n// Output demultiplexer - route decoder output to appropriate display\n// When a display is not selected, turn off all segments (common anode = all high)\nalways_comb begin\n    case (mux_select)\n        1'b0: begin\n            segs0 = decoder_segs;    // Display digit0\n            segs1 = 7'b111_1111;     // Turn off display 1\n        end\n        1'b1: begin\n            segs0 = 7'b111_1111;     // Turn off display 0\n            segs1 = decoder_segs;    // Display digit1\n        end\n        default: begin\n            segs0 = 7'b111_1111;\n            segs1 = 7'b111_1111;\n        end\n    endcase\nend\nendmodule\nlogic clk;\nlogic reset;\nlogic [3:0] digit0;\nlogic [3:0] digit1;\nlogic [6:0] segs0;\nlogic [6:0] segs1;\n\n// Instantiate the Device Under Test (DUT)\nseven_seg_time_mux dut (\n    .clk(clk),\n    .reset(reset),\n    .digit0(digit0),\n    .digit1(digit1),\n    .segs0(segs0),\n    .segs1(segs1)\n);\n\n// Clock generation (50MHz system clock)\ninitial begin\n    clk = 0;\n    forever #10 clk = ~clk; // 20ns period = 50MHz\nend\n\n// Test stimulus\ninitial begin\n    // Initialize signals\n    reset = 1;\n    digit0 = 4'h0;\n    digit1 = 4'h0;\n    \n    // Release reset\n    #100 reset = 0;\n    \n    // Test case 1: Display 3 and 7\n    #1000 digit0 = 4'h3; digit1 = 4'h7;\n    \n    // Test case 2: Display A and F (hex)\n    #5000 digit0 = 4'hA; digit1 = 4'hF;\n    \n    // Test case 3: Display 5 and 2\n    #5000 digit0 = 4'h5; digit1 = 4'h2;\n    \n    // Test case 4: Display 8 and 1\n    #5000 digit0 = 4'h8; digit1 = 4'h1;\n    \n    // Finish simulation\n    #10000 $finish;\nend\n\n// Monitor key signals\ninitial begin\n    $monitor(\"Time=%0t, digit0=%h, digit1=%h, segs0=%b, segs1=%b\", \n             $time, digit0, digit1, segs0, segs1);\nend\n\n// Generate VCD file for waveform viewing\ninitial begin\n    $dumpfile(\"seven_seg_mux.vcd\");\n    $dumpvars(0, seven_seg_time_mux_tb);\nend\nendmodule\nBoth designs ran into the issue that the “loop count limit [of the clock] exceeded forever never breaks”. This occured because both LLM outputs created associated testbenches. I tried to take out this forever statement, and make the clock tick similarly to my own testbenches. However, when I did this, I received a “Synthesize Design Completed, Lattice Synthesis Engine Failed” error."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "Lab 4: Digital Audio\n\nIntroduction\n\n\nDesign and Testing Methodology\n\n\nTechnical Documentation\n\n\nBlock Diagram\n\n\nSchematic\n\n\nResults and Discussion\n\n\nTestbench Simulation\n\n\nConclusion\n\n\nAI Prototype Summary"
  },
  {
    "objectID": "posts/second-post.html",
    "href": "posts/second-post.html",
    "title": "Blog 1",
    "section": "",
    "text": "As of today, I have completed my first MicroPs lab. Overall, I did not think that the tasks were too challenging. I have PCB assembly experience from my summer internship, and very quickly understood what was needed to be done on the FPGA. That said, I ended up spending around twenty hours working. I did not anticipate some issues, such as missing components and the fact that the software took a very long time to load. However, I learned many lessons about what I will not allow myself to do in the future.\nLesson 1- I was quite absent-minded when configuring my project. I accidentally created a Verilog file instead of a SystemVerilog file, which caused syntax errors and took me around an hour to discover. I also gave my files/modules undescriptive names twice in a row. In order to rename the files, while making sure the whole project/file tree stayed consistent, I had to start a new project. This involved a lot of time wasted waiting for Radiant to power up. I would also often close the Programmer after being thrown the J-Link issue, even though this wasn’t necessary. This meant that I would have to wait for the Programmer to open almost every time I tried to reprogram the FPGA, which always took a while.\nLesson 2- Having my check off on Thursday meant that I was working at a slower and less efficient pace than my peers in lab, because I didn’t have the stress of a near upcoming assignment. I think I spent more time in lab than was necessary, not doing efficient work. As a result, the two nights before my Thursday check-in were longer nights for me.\nI do not feel positively toward how I managed my time and brain resources on this first lab. However, I am foremost taking this as a learning experience. I am happy this happened to me now and made me realize I have to get into shape before more difficult labs come along."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "E155 Course Website\nE155 Github Repository"
  },
  {
    "objectID": "resources.html#portfolio-resources",
    "href": "resources.html#portfolio-resources",
    "title": "Resources",
    "section": "",
    "text": "E155 Course Website\nE155 Github Repository"
  }
]