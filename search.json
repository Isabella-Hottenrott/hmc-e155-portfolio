[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Isabella’s Blog Page\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBlog 1\n\n\nReflections on Lab 1\n\n\n\n\n\nSep 4, 2025\n\n\nBella Hottenrott\n\n\n\n\n\n\n\n\n\n\n\n\nBlog 0\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 28, 2025\n\n\nBella Hottenrott\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Bella Hottenrott is a senior Engineering major at Harvey Mudd College. Her background lies in electrical, computer, and controls engineering. Over the weekends, she and her friends like to go surfing, hiking, and exploring in LA. When she has time to herself, she is almost certainly listening to a podcast, on a run, or making herself a coffee."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Blog 0",
    "section": "",
    "text": "I am excited to take E155 this semester. I remember seeing the seniors going to lab for this class when I was a freshman. Now I am in my final year and feel I have a strong enough engineering background to take this course. I am excited to challenge myself. Most of all, I am excited to build the resilience and debugging skills that this course develops.\nI found Lab 0 relatively easy. It allowed me to reflect on the Git, Linux, and Quarto familiarity that I’ve gained over the past year. I am not sure that I would have been able to set up this portfolio a year ago."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "Lab 3: Keypad Scanner\n\nIntroduction\nIn this lab, a design was implemented on the UPduino v3.1 FPGA board to display a continuous stream of hexadecimal inputs from a 4-by-4 matrix scanner onto a HDSP-521A dual segment LED display. The number of pins on the FPGA board limits this implementation to time-multiplex between the two output signals on the Dual Segment display, meaning much of the logic and breadboarding from Lab 2 was borrowed. The task of this lab must overcome two main challenges: one involving asynchronous inputs from a user, and the other involving “switch bouncing”.\n\n\nDesign and Testing Methodology\nTo address these challenges prsented by this lab, my design thought process relied heavily on the E85 style of a “Datapath” and “Control Unit”. The “Datapath” deals with inputs, outputs, and operations on or intermediate storage of logic. The “Control Unit” is my FSM, and deals with the flow between “states” of my abstract implementation, sending and recieving control signals to the “Datapath” section to facilitate the proper advancement of logic. The rest of my logic was lots of combinational logic to encode signals relating the columns and rows. I used the HSOSC on-board high-speed oscillator to generate a 12 MHz clock signal that the design ran on. This signal was also divided to produce an second oscillator ticking at 60 Hz to allow for the time multiplexing of the display. 60 Hz is the frequency at which the human eye can no longer percieve refresh rates.\n\n\nTechnical Documentation\n\nVerilog\nAs introduced in the previous section, the ideation for this design was inspired by the E85 separation of a “Controller” from a “Datapath”. The “Controller” of my design refers to the FSM, which is purely in charge of tracking ‘control’ signals and transitions between states. This idea is sketched up very generally in the image below.\n\n\n\nFigure 0: General Inspiration of Lab 3 Design\n\n\nMy FSM is composed of six states: State 0 (Scan), State 1 (Synch), State 2 (Debounce), State 3 (Checking), State 4 (Send), and State 5 (Release). It is a Moore Machine, meaning outputs only depend on current state. S0-&gt;S1 occurs when a row receives and input, S1-&gt;S2 occurs when the synchronizer is done, S2-&gt;S3 occurs when the douncer is done, S3-&gt;S4 occurs if the same button is still pressed, otherwise S3-&gt;S0 occurs. S4-&gt;S5 occurs no matter the input, and S5-&gt;S0 occurs once the button is released. The Finite State Machine can be seen in the figure below.\n\n\n\nFigure 1: FSM for Lab 3 Design\n\n\nThe output and next state logic is outlined in the table below.\n\n\n\nFigure 2: Output and Next State Logic\n\n\nThe modules on the datapath facilitate the proper advancement of logic.\nThe scancounter respresents the four columns by a two bit number. This module increments the two bit representation every rising edge of the clock, therefore sweeping through the four columns. The scancounter has a reset and enable signal.\nThe synchronizer is represented as two registers that synchronize asynchronous signals to the clock. The synchronizer has an enable and reset, as well as a “done” signal that goes HIGH on the clock cycle that synchronization completes. Essentially, then, this module is composed of two “states”: the ‘active synchronizing’ state, and the ‘done synchronizing state’.\nThe debouncer acts as a counter that, when enabled, increments every rising clock edge. If disabled, the counter is set to zero. Once the counter has reached 600,000 clock ticks, representing that 50 ms have passed based on a 12 MHz clock, it sends off a “done” signal. The debouncer has an enable and reset. Essentially, then, this module is also composed of two “states”: the ‘active debounce-counting’ state, and the ‘not counting state’.\nThe seg_ff acts as a flip-flop that when enabled, first writes to segment 0, and then writes the old value of segment 0 to segment 1. This ensures that the most recent hex digit from the keypad is displayed on the right, and the previous digit is shown on the left. This flip flop has an enable and reset. When disabled, the segments are turned off.\n\n\nBreadboard\nMuch of the breadboarding for this lab took from Lab 3, as the dual segment display needed to be time multiplexed and the same single set of GPIO pins was used.\nThe HDSP-521A required a larger current draw than the FPGA can output, which was addressed by two 2N3906 PNP transistors. 330 Ω resistors were placed at the cathodes of the diodes to ensure a 3 mA current pull through the segment, over the (3.3 V - 0.25 Vce -1.85 Vf) = 1.2 V drop, when ON. Calculations for the current limiting resistors between the cathodes and GPIO pins can be found below.\n\n\n\nFigure 3: Resistor Calculation\n\n\nA 460 Ω resistor was placed between the transistor base and the GPIO pin to limit the current draw to under 5 mA through the base, as specified by the datasheet. Calculations for this component value can be found below.\n\n\n\nFigure 4: Transistor Base Current Calculation\n\n\nTo control the input to the Seven Segment Display, a priority encoder was used. The output signals were mapped to their respective pins on the input of the HDSP-521A Seven Segment Display.\nThe Keypad has eight pins for the four columns and four rows, each connected to the breadboard. The pin encoding from Pin0 to Pin 8: is as follows {R0, C0, R3, R1, R2, C1, C2, C3}, where Rx represents a row and Cx represents a column. The columns are driven by the GPIO pins as active HIGH. The rows output to the GPIO pins, and are also conencted to 100 kΩ pull down resistors to avoid floating values.\n\n\n\nBlock Diagram\nThe top level module of this project is called lab3_ih and takes in inputs: reset (from the dev Board), and inputrows (from the keypad). lab3_ih outputs four signals: cols (to the keypad), segmentOut (to the segmanet cathodes), anodeZeroOut (to the base of transistor 0), anodeOneOut (to the base of transistor 1). lab3_ih includes nine submodules: the high-speed oscillator block (hf_osc), the clock divider to 60 Hz (clock_div), the FSM (FSM), the Datapath (DataPath), two column/row to segment encoders (colrowseg(0/1)) and two seven segment encoders (segments(0/1)) for the zeroeth and first segments respectively, and an anode-selecting module (anodeselect). Within the DataPath module, there are five submodules as well. These include a module to scan through kepad columns (scancounter), a module to encode the columns (combcol), a module to synchronize potential asynchronous inputs (synchronizer), a module to eliminate the effects of switch mechanical bouncing (debouncer), and a module to output segments to the display such that the first entry is displayed on the right (seg_ff). The modules inside of DataPath.sv function mostly as versions of some form of counter of flop enable.\n\n\n\nFigure 5: Block Diagram\n\n\n\n\nSchematic\nThe schematic above illustrates the physical layout on the breadboard for this project. Corresponding diode cathodes from the two seven segment displays were the same node (segment 1 A is the same node as segment 2 A, etc). These were connected in series with a 330 Ω current-limiting resistor to the GPIO pins. The on-board LEDs required 1 kΩ resistors to their limit current. The emitter of the transistor is powered by 3.3 V, while the collector goes straight to the segment anodes. The base of the PNP transistor is in series with a 460 Ω resistor such that less than 5mA of current is drawn from the GPIO pin, which lies within specs. The columns of the keypad are wired directly to their respective FPGA pins. The rows of the keypad are similarly wired directly to their respective FPGA pins, as well as 100 kΩ pull down resistors.\n\n\n\nFigure 6: Schematic\n\n\n\n\nResults and Discussion\nThis design met the intended objectives. The testbenches created for the different modules all passed. The Dual LED Segment correctly displayed the inputted hexadecimal digits typed into the keypad. The system did not lock or get confused when an invalid, asynchronous, or mechanically-bounced input was punched in. The two digits were illuminated and distinct.\nThe choice to debounce in the method that I selected has some tradeoffs. The 50 ms counter is a “hard-coded” method of debouncing, and not at all responsive to different degrees of mechanical bouncing. It treats all switch bounces equally, providing 50 ms to recover. An alternative to this choice could have been implementing a second FSM that tracked states of whether any button was pushed. Such a design choice could have taken intermediate feedback during a button press, creating a more tailored debouncing mechanism. This is more complicated and entails re-accepting row inputs during a button push, which raises the possibility that operations would continue instead of remaining frozen during a button press. Another implementation might have been using an RC low pass filter. This would have made debugging more complicated, because debouncing signals are no longer in Verilog, but instead manifest on the breadboard. Overall, I found my counter implementation to be the simplest while still sufficient.\n\n\nTestbench Simulation\nA testbench simulation was produced for every module in the design.\n\ntb_lab3_ih:\nThe testbench for lab3_ih can be found here. Seven different potential button presses were tested and proven to output the correct value. Some of these included corner cases, such as what happens when there is a double press, or what happens when second press is asserted while the first press is still held. Additionally, this testbench checked that columns didn’t continue to cycle when they weren’t supposed to. The input four bit row logic was specified, as well as the four bit column logic, allowing me to decipher which key was being pressed. The correct outputs, as well as the correct anode illumination, was verified in this testbench. No errors occured.\n\n\n\nFigure 7: Testbench Simulation Results for lab3_ih\n\n\n\n\ntb_DataPath:\nThe testbench for the DataPath module can be found here. This testbench tested different possible inputs into the DataPath module. The testbench verified the output of all the different combinations of possible signal inputs from the FSM module, and accounted for the timing and cohesion of all the submodules contained within DataPath.sv. The different test cases attempted to demonstrate basic functionality, as well as target corner cases, such as when invalid entries were asserted. No errors occured.\n\n\n\nFigure 8: Testbench Simulation Results for DataPath\n\n\n\n\ntb_FSM:\nThe testbench for the FSM module can be found here. This testbench tested all different possible combinations of inputs into the FSM module. The testbench extracted the state and next state of the system, to verify that these matched the expected state. Two whole cycles through the FSM were practised. No errors occured.\n\n\n\nFigure 9: Testbench Simulation Results for FSM\n\n\n\n\ntb_CombCol:\nThe testbench for the CombCol module can be found here. This testbench tested all different possible combinations of inputs into the CombCol module- a simple encoder. No errors occured.\n\n\n\nFigure 10: Testbench Simulation Results for CombCol\n\n\n\n\ntb_clock_div:\nThe testbench for the clock divider module can be found here. A test oscillator was produced that ticked every 100000 time stamps, where two time stamps represent a full clock cycle. The test oscillator was compared to that produced by the clock_div module when fed in the testbench clock signal. Both oscillators can be seen to rise and fall simulataneously. The HSOSC produces a 12 MHz clock. The clock divider module has been shown to divide the input clock signal by 200000. 12 MHz/200000 = 60 Hz, which is the targeted frequency switching between displays. No errors occured.\n\n\n\nFigure 11: Testbench Simulation Results for clock_div\n\n\n\n\ntb_anodeselect:\nThe testbench for the anodeselect module can be found here. The test verifies that the correct segment output and segment anode are sent off the FPGA at the correct multiplexed timestamp. The test verifies that the two segments are never sent out at the same time. No errors occured.\n\n\n\nFigure 12: Testbench Simulation Results for anodeselect\n\n\n\n\ntb_colrowseg:\nThe testbench for the colrowseg module can be found here. The test asserts all possible inputs for this combinational module. No errors occured.\n\n\n\nFigure 13: Testbench Simulation Results for colrowseg\n\n\n\n\ntb_debouncer:\nThe testbench for the debouncer module can be found here. The enable logic for the debouncing was tested. It was also 600000 timestamps were required for the debouncing counter to expire. This equates to 50 ms when clk comes from the 12 MHz HSOSC. No errors occured.\n\n\n\nFigure 14: Testbench Simulation Results for debouncer\n\n\n\n\ntb_scancounter:\nThe testbench for the scancounter module can be found here. This testbench verifies that the scanning of columns cycles through columns and equal and even amount. Correct response to the enable signal was proven. No errors occured.\n\n\n\nFigure 15: Testbench Simulation Results for scancounter\n\n\n\n\ntb_seg_ff:\nThe testbench for the seg_ff module can be found here. A variety of different test cases were tested against the seg_ff module. Different row and column values were tested, including invalid ones, producing segment0 and segment1 signals. Correct response to the enable signal was proven. No errors occured.\n\n\n\nFigure 16: Testbench Simulation Results for seg_ff\n\n\n\n\ntb_synchronizer:\nThe testbench for the synchronizer module can be found here. Test cases were tested against the synchronizer module, ensuring that after two cycles, the correct logic was synchronized with the clock. Correct response to the enable signal was proven, as well as the correct assertion of a “done” signal. No errors occured.\n\n\n\nFigure 17: Testbench Simulation Results for synchronizer\n\n\n\n\n\nConclusion\nThis design successfully illuminated a Dual Seven Segment Display based on a stream of inputs from a 4x4 keypad, using time-multiplexed outpus. The design handled asynchronous inputs and mechanical boucning of switches. Proper component selection allowed for strong illumination of the display. I spent a total of 40 hours on this lab.\n\n\nAI Prototype Summary\nThe first prompt that I provided the LLM was a monolithic prompts:\n    \"Target device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\n\n    Write synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement:\n\n    A clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator.\n    A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release.\n    A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness.\n    Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.\" \nIn return, I recieved the following design linked here that synthesized. This verilog produced a design with four FSM states. The instantiation of these states can be seen below. There was no FSM module specifically, and state transitions were scattered throughout the module.  Otherwise, the commented logic provided by the LLM followed a path that made sense. The encodings for the segments were correct.\nNext, I prompted the LLM in a modular manner such that it would decompose FSMs. The first of these prompts was:\n    \"Target device: Lattice iCE40 UP5K FPGA.\n\n    Overall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display.\n\n    Current Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior:\n\n    When a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse.\n    While any key remains pressed, do not accept additional keys.\n    Only after keys are released should a subsequent press be recognized.\n    This should handle debouncing of the keys.\n    Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here.\"\nIn return, I recieved the following design linked here that synthesized.\nThe second modular prompt was: “Target device: Lattice iCE40 UP5K FPGA.\n    Write a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior:\n\n    Iterate columns at a suitable scan rate derived from the divided clock and sample rows.\n    When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed.\n    Provide a boolean signal indicating whether any key is currently pressed.\n    Use clean state encoding and synchronous logic; avoid combinational feedback and latches.\"\nIn return, I recieved the following design linked here that synthesized.\nThe design decoded the columns and rows in a case statement, verbosely breaking down every column and row possibility. Immediately, the row and column combinations were converted into the hex value that was pressed.\n\n\n\nFigure 19: AI Proto Bii Breakdownof Columns and Rows\n\n\nThe final of the modular prompts was: “Target device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source.\n    Write a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements:\n\n    Update the displayed digits only when a new key is registered.\n    Ensure equal apparent brightness and no visible flicker.\n    Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs.\n    Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.\"\nIn return, I recieved the following design linked here.\n\n\n\nFigure 20: AI Proto Biii Unsynthesizable Clock\n\n\nThis was the first of the designs returned by the LLM that did not synthesize. Claude attempted to import the wrong High Frequency Oscillator, as shown in the image above."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "Lab 5: Interrupts\n\nIntroduction\n\n\nDesign and Testing Methodology\n\n\nTechnical Documentation\n\n\nBlock Diagram\n\n\nSchematic\n\n\nResults and Discussion\n\n\nTestbench Simulation\n\n\nConclusion\n\n\nAI Prototype Summary"
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "",
    "text": "Lab 7: The Advanced Encryption Standard\n\nIntroduction\n\n\nDesign and Testing Methodology\n\n\nTechnical Documentation\n\n\nBlock Diagram\n\n\nSchematic\n\n\nResults and Discussion\n\n\nTestbench Simulation\n\n\nConclusion\n\n\nAI Prototype Summary"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Lab 1: FPGA and MCU Setup and Testing\n\nIntroduction\nIn this lab, a design was implemented on the UPduino v3.1 FPGA to interface with and demonstrate the proper assembly of the E155 Development Board. This lab also exhibited the functionalities of the Dev Board’s LEDs, the FPGA’s on-board high-speed oscillator, and a Seven Segment Display.\n\n\nDesign and Testing Methodology\nThe iCE40 UltraPlus HSOSC primitive- an on-board high-speed oscillator- was used to generate a clock signal at 48 MHz.\nA separate clock divider module was created to divide the HSOSC signal to a frequency of 2.4 Hz using a counter that reset every 10,000 counts. This drove an external LED.\nLogic to control the other two on-board LEDs included a simple XOR gate and AND gate between two sets of switches.\nTo control the input to the Seven Segment Display, a priority encoder was used. The output signals were mapped to their respective pins on the input of the HDSP-511A Seven Segment Display. 3.3V were applied to the common anode of the display. To turn a segment ON, the respective GPIO pin was grounded, producing a 3.3V drop across the segment’s anode. The forward voltage of the segments’ diodes is 1.95V. The current flowing through the diode was chosen to be 1mA. Therefore the value of the current limiting resistor placed in series between the cathode and GPIO pin was 1 kΩ. Calculations for this component value can be found below.\n\n\n\nFigure 1: Calculations for the current-limiting resistor values\n\n\nTo turn a segment OFF, the respective GPIO pin was set to 3.3V, producing no voltage drop across the segment, therefore allowing no current to flow.\n\n\nTechnical Documentation\nThe source code for Lab 1 can be found in the following GitHub repository.\n\nBlock Diagram\n\n\n\nFigure 2: Block Diagram of the lab1_ih verilog design\n\n\nThe block diagram above illustrates the lab1_ih design. The top level module is called lab1_ih and takes the input s[3:0] and outputs led[2:0] and segs[6:0], communicating with the GPIO pins. Lab1_ih includes three submodules: the high-speed oscillator block (hf_osc), the seven segments priority encoder (segments), and the clock divider to 2.4 Hz (clock_div).\n\n\nSchematic\n\n\n\nFigure 3: Schematic of the Physical Circuit\n\n\nThe schematic above illustrates the physical layout on the breadboard. The diode cathodes from the seven segment display were connected in series with a 1 kΩ current-limiting resistor. Similarly, the on-board LEDs required 1 kΩ resistors to their limit current. Internal 100kΩ pull-up resistors were used to keep the active low SW7 from floating.\n\n\n\nResults and Discussion\nThis design met the intended objectives. All switches perform the intended logic, as can be demonstrated on the board by performing all switch combinations. Testbench simulations to verify the SystemVerilog design were produced for this lab.\n\n\nTestbench Simulation\n\n\n\nFigure 5: Waveforms for tb_lab1_ih\n\n\nAbove are the waveforms produced by the testbench of the lab1_ih module. All possible combinations of input switch values were explicitly tested. The resulting led and single segment display were tested against expectations. The HSOSC primitive was imported into the testbench to verify funcitonality. No errors occured.\n\n\n\nFigure 6: Waveforms for tb_segments\n\n\nAbove are the waveforms produced by the testbench of the segments module. All possible combinations of input switch values were explicitly tested. The resulting single segment display outputs were tested against expectations. No errors occured.\n\n\n\nFigure 7: Waveforms for tb_clock_div\n\n\nAbove are the waveforms produced by the testbench of the clock_div module. A test oscillator was produced that ticked every 20,000,000 time stamps. This mimics the behavior of the clock divider, as the led is desired to oscillate at a 2.4 Hz frequency, or 20,000,000 times every edge of the 48 MHz HSOSC clock. 48 MHz/20,000,000 = 2.4 Hz. The test oscillator was compared to that produced by the clock_div module when fed in the testbench clock signal. Both oscillators can be seen to rise and fall simulataneously. No errors occured.\n\n\nConclusion\nThe design successfully blinked an external LED using the on-board high-speed oscillator. Doing so demonstrated that the development board was properly assembled. I spent a total of twenty hours working on this lab. Producing the testbench redos took me an additional 2 hours.\n\n\nAI Prototype Summary\nThe prompt that I provided the LLM was: “Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”\nIn response, it provided me with the following:\n// Blink an LED at ~2 Hz using the iCE40UP5K internal HFOSC.\n// Toolchains: Lattice Radiant/iCEcube2 or open-source (yosys/nextpnr-ice40).\n\nmodule up5k_led_blink_2hz (\n    output logic led_o   // drive your LED pin (active-high assumed)\n);\n\nlogic clk_12mhz;\n\nSB_HFOSC u_hfosc (\n    .CLKHFEN (1'b1),   // enable output (assert after 100 µs PU time)\n    .CLKHFPU (1'b1),   // power-up oscillator\n    .CLKHF   (clk_12mhz)\n);\n\nlocalparam int unsigned F_CLK_HZ = 12_000_000;\nlocalparam int unsigned F_BLINK_HZ = 2;\nlocalparam int unsigned TICKS_PER_TOGGLE = F_CLK_HZ / (2 * F_BLINK_HZ);\n\nlocalparam int COUNTER_W = $clog2(TICKS_PER_TOGGLE);\nlogic [COUNTER_W-1:0] tick_cnt /* synthesis preserve */;\n\nalways_ff @(posedge clk_12mhz) begin\n    if (tick_cnt == TICKS_PER_TOGGLE-1) begin\n        tick_cnt &lt;= '0;\n        led_o    &lt;= ~led_o;       // toggle at 2 Hz\n    end else begin\n        tick_cnt &lt;= tick_cnt + 1;\n    end\nend\n\ninitial led_o = 1'b0;\n\nendmodule\nWhen I attempted to synthesize this design, I thrown the error “instantiating unknown module SB_HFSOSC. VERI-1063”. I typed the error message back into the LLM, and it corrected itself by instantiating the module “SB_HFOSC”. The LLM had falsely named the Lattice iCE40/UP5K primitive of the on-board FPGA.\nI would overall rate the quality of the output poorly. I used ChatGPT 5 for this task, and would have expected it to not make such a basic and obvious mistake. The prompt asked to produce a very simple design, so I found it surprising that the LLM’s output didn’t synthesize on the first try. I also found the mistake surprising, because there should be a correlation between “iCE40/UP5K” and “SB_HFOSC”, rather than “SB_HFSOSC” in the data that the chatbot used to create its answer.\nOtherwise, the logic that the LLM created made sense, and the chatbot attempted to use local parameters and calculations to arrive at values necessary for the clock division. This makes the design modular."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface\n\nIntroduction\n\n\nDesign and Testing Methodology\n\n\nTechnical Documentation\n\n\nBlock Diagram\n\n\nSchematic\n\n\nResults and Discussion\n\n\nTestbench Simulation\n\n\nConclusion\n\n\nAI Prototype Summary"
  },
  {
    "objectID": "labs/labs.html",
    "href": "labs/labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1: FPGA and MCU Setup and Testing"
  },
  {
    "objectID": "labs/labs.html#lab-1",
    "href": "labs/labs.html#lab-1",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1: FPGA and MCU Setup and Testing"
  },
  {
    "objectID": "labs/labs.html#lab-2",
    "href": "labs/labs.html#lab-2",
    "title": "E155 Labs",
    "section": "Lab 2",
    "text": "Lab 2\nLab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs/labs.html#lab-3",
    "href": "labs/labs.html#lab-3",
    "title": "E155 Labs",
    "section": "Lab 3",
    "text": "Lab 3\nLab 3: Keypad Scanner"
  },
  {
    "objectID": "labs/labs.html#lab-4",
    "href": "labs/labs.html#lab-4",
    "title": "E155 Labs",
    "section": "Lab 4",
    "text": "Lab 4\nLab 4: Digital Audio"
  },
  {
    "objectID": "labs/labs.html#lab-5",
    "href": "labs/labs.html#lab-5",
    "title": "E155 Labs",
    "section": "Lab 5",
    "text": "Lab 5\nLab 5: Interrupts"
  },
  {
    "objectID": "labs/labs.html#lab-6",
    "href": "labs/labs.html#lab-6",
    "title": "E155 Labs",
    "section": "Lab 6",
    "text": "Lab 6\nLab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs/labs.html#lab-7",
    "href": "labs/labs.html#lab-7",
    "title": "E155 Labs",
    "section": "Lab 7",
    "text": "Lab 7\nLab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "Lab 2: Multiplexed 7-Segment Display\n\nIntroduction\nIn this lab, a design was implemented on the UPduino v3.1 FPGA that time-multiplexed between two seven-segment displays. The design utilized only one set of GPIO pins, and only one seven segment HDL module. The time multiplexing occured at a fast enough rate that switching between segments was not discernable to the human eye.\n\n\nDesign and Testing Methodology\nThe iCE40 UltraPlus HSOSC primitive was used to generate a clock signal, which was stepped down to a 60 Hz signal that the design was based on. At this frequency, the human eye can no longer percieve refresh rates. This frequency also ensured that bleeding did not occur between the two segments.\nAn 8-pin dip switch controls the HDSP-521A Dual Seven Segment Display, where the first four switches correspond to the first segment, and final four correspond to the second. When the internal clock is low, the input from the first four switches is selected, and when the clock is high, the input from the final four are selected.\nAt the same time, when the clock is low, a signal is sent to drive the common anode of the first segment. When the clock is high, a separate signal drives the common anode of the second segment.\nThe sum of the two hex values on the HDSP-521A Display is represented in binary on the on-board LEDs of the E155 Development Board. These diodes are in series with 1 kΩ resistors to limit current.\nThe Seven Segment Display module- a priority encoder- was used to convert the desired switch inputs into an output hex digit. The HDSP521A required a larger current draw than the FPGA can output, which was addressed by two 2N3906 PNP transistors. 330 Ω resistors were placed at the cathodes of the diodes to ensure a 3 mA current pull through the segment, over the (3.3 V - 0.25 Vce -1.85 Vf) = 1.2 V drop, when ON. Calculations for the current limiting resistors between the cathodes and GPIO pins can be found below.\n\n\n\nFigure 0: Resistor Calculation\n\n\nA 460 Ω resistor was placed between the transisotr base and the GPIO pin to limit the current draw to under 5 mA through the base, as specified by the datasheet. Calculations for this component value can be found below.\n\n\n\nFigure 1: Transistor Base Current Calculation\n\n\nTo control the input to the Seven Segment Display, a priority encoder was used. The output signals were mapped to their respective pins on the input of the HDSP-511A Seven Segment Display.\n\n\nTechnical Documentation\nThe source code for Lab 2 can be found in the following GitHub repository.\n\n\nBlock Diagram\n\n\n\nFigure 2: Block Diagram of the lab2_ih verilog design\n\n\nThe block diagram above illustrates the lab2_ih design. The top level module is called lab2_ih and takes in inputs: reset, sw1, and sw2. Lab2_ih outputs to five leds (led), a single set of GPIO pins for the dual seven segment (segs), to both transistors to illuminate the proper segment anode (anodeOne, anodeTwo), and to the two remaining on-board LEDs to keep them from floating (bottomLEDs). Lab2_ih includes five submodules: the high-speed oscillator block (hf_osc), the clock divider to 60 Hz (clock_div), the adder (adder), the seven segments priority encoder (segments), and the anode-selecting module (anodeselect).\n\n\nSchematic\nThe schematic above illustrates the physical layout on the breadboard. Corresponding diode cathodes from the two seven segment displays were the same node (segment 1 A is the same node as segment 2 A, etc). These were connected in series with a 330 Ω current-limiting resistor to the GPIO pins. The on-board LEDs required 1 kΩ resistors to their limit current. The emitter of the transistor is powered by 3.3 V, while the collector goes straight to the segment anodes. The base of the PNP transistor is in series with a 460 Ω resistor such that less than 5mA of current is drawn from the GPIO pin, which lies within specs.\n\n\n\nFigure 3: Schematic of the Breadboard\n\n\n\n\nResults and Discussion\nThis design met the intended objectives. All switches correctly spoke with the board, the proper LED-sum combinations were calculated and illuminated, and the Seven Segment Display shows two distinct hex values without any discernable flickering or bleeding.\n\n\nTestbench Simulation\nA testbench simulation was produced for every module in the design.\n\ntb_lab2_ih:\nThe testbench for lab2_ih can be found here. The high speed clock was commented out to run this simulation, and 10 known cases were tested against the design. No errors occured.\n\n\n\nFigure 4: Testbench Simulation Results for lab2_ih\n\n\n\n\ntb_segments:\nThe testbench for the segments module can be found here. All possible combinations of input switch values were explicitly tested. No errors occured.\n\n\n\nFigure 5: Testbench Simulation Results for segments\n\n\n\n\ntb_clock_div:\nThe testbench for the clock divider module can be found here. A test oscillator was produced that ticked every 800000 time stamps, where two time stamps represent a full clock cycle. The test oscillator was compared to that produced by the clock_div module when fed in the testbench clock signal. Both oscillators can be seen to rise and fall simulataneously. The HSOSC produces a 48 MHz clock. The clock divider module has been shown to divide the input clock signal by 800000. 48 MHz/800000 = 60 Hz, which is the targeted frequency switching between displays. No errors occured.\n\n\n\nFigure 6: Testbench Simulation Results for clock_div\n\n\n\n\ntb_anodeselect:\nThe testbench for the anodeselect module can be found here. The test verifies that the correct switch value is sent to the segment modules, as well as the corresponding correct anode, across 12 handwritten vectors. The test verifies that the two anodes are never HIGH at the same timestamp. No errors occured.\n\n\n\nFigure 7: Testbench Simulation Results for anodeselect\n\n\n\n\ntb_adder:\nThe testbench for the adder module can be found here. A system verilog function iterates through all possible input-addition combinations to verify all possible additions. No errors occured.\n\n\n\nFigure 8: Testbench Simulation Results for adder\n\n\n\n\n\nConclusion\nThis design design illuminated a Dual Seven Segment Display using a single segment module through the use of time-multiplexing. A transistor circuit and selected resistors were used to ensure that sufficient, but not excessive current, flows through components based on datasheet values. I spent a total of 18 hours on this lab.\n\n\nAI Prototype Summary\nThe prompt that I provided the LLM was: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.” In return, I recieved the following design that did not synthesize:\n// Time Multiplexed Seven Segment Display Controller\n// This module uses a single seven segment decoder to drive two displays\n\nmodule seven_seg_mux (\n    input  logic        clk,\n    input  logic        reset_n,\n    input  logic [3:0]  digit0_in,    // First 4-bit input\n    input  logic [3:0]  digit1_in,    // Second 4-bit input\n    output logic [6:0]  seg0_out,     // Seven segment outputs for display 0\n    output logic [6:0]  seg1_out,     // Seven segment outputs for display 1\n    output logic        digit0_enable, // Enable signal for display 0\n    output logic        digit1_enable  // Enable signal for display 1\n);\n\n    // Internal signals\n    logic [3:0] mux_input;\n    logic [6:0] decoder_output;\n    logic       mux_select;\n    logic       slow_clk;\n\n    // Instantiate oscillator for timing\n    oscillator u_osc (\n        .clk(clk),\n        .reset_n(reset_n),\n        .slow_clk(slow_clk)\n    );\n\n    // Generate multiplexer select signal\n    always_ff @(posedge slow_clk or negedge reset_n) begin\n        if (!reset_n)\n            mux_select &lt;= 1'b0;\n        else\n            mux_select &lt;= ~mux_select;\n    end\n\n    // Input multiplexer\n    always_comb begin\n        case (mux_select)\n            1'b0: mux_input = digit0_in;\n            1'b1: mux_input = digit1_in;\n        endcase\n    end\n\n    // Instantiate seven segment decoder\n    seven_seg_decoder u_decoder (\n        .bin_in(mux_input),\n        .seg_out(decoder_output)\n    );\n\n    // Output demultiplexer and enable generation\n    always_comb begin\n        case (mux_select)\n            1'b0: begin\n                seg0_out = decoder_output;\n                seg1_out = 7'b1111111;  // All segments off (common anode)\n                digit0_enable = 1'b0;   // Active low enable\n                digit1_enable = 1'b1;   // Disabled\n            end\n            1'b1: begin\n                seg0_out = 7'b1111111;  // All segments off\n                seg1_out = decoder_output;\n                digit0_enable = 1'b1;   // Disabled\n                digit1_enable = 1'b0;   // Active low enable\n            end\n        endcase\n    end\n\nendmodule\n\n// Seven Segment Decoder Module\n// Converts 4-bit binary input to seven segment display pattern\n// Common anode configuration (active low outputs)\nmodule seven_seg_decoder (\n    input  logic [3:0] bin_in,\n    output logic [6:0] seg_out\n);\n\n    // Segment mapping: seg_out = {g, f, e, d, c, b, a}\n    // Common anode: 0 = segment on, 1 = segment off\n    always_comb begin\n        case (bin_in)\n            4'h0: seg_out = 7'b1000000; // 0\n            4'h1: seg_out = 7'b1111001; // 1\n            4'h2: seg_out = 7'b0100100; // 2\n            4'h3: seg_out = 7'b0110000; // 3\n            4'h4: seg_out = 7'b0011001; // 4\n            4'h5: seg_out = 7'b0010010; // 5\n            4'h6: seg_out = 7'b0000010; // 6\n            4'h7: seg_out = 7'b1111000; // 7\n            4'h8: seg_out = 7'b0000000; // 8\n            4'h9: seg_out = 7'b0010000; // 9\n            4'hA: seg_out = 7'b0001000; // A\n            4'hB: seg_out = 7'b0000011; // b\n            4'hC: seg_out = 7'b1000110; // C\n            4'hD: seg_out = 7'b0100001; // d\n            4'hE: seg_out = 7'b0000110; // E\n            4'hF: seg_out = 7'b0001110; // F\n        endcase\n    end\n\nendmodule\n\n// Simple Oscillator Module\n// Generates a slower clock for multiplexing\nmodule oscillator (\n    input  logic clk,\n    input  logic reset_n,\n    output logic slow_clk\n);\n\n    parameter DIVIDE_BY = 100000; // Adjust for desired refresh rate\n    logic [$clog2(DIVIDE_BY)-1:0] counter;\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            counter &lt;= '0;\n            slow_clk &lt;= 1'b0;\n        end else begin\n            if (counter == DIVIDE_BY - 1) begin\n                counter &lt;= '0;\n                slow_clk &lt;= ~slow_clk;\n            end else begin\n                counter &lt;= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\n// Testbench for verification\nmodule seven_seg_mux_tb;\n\n    logic        clk;\n    logic        reset_n;\n    logic [3:0]  digit0_in;\n    logic [3:0]  digit1_in;\n    logic [6:0]  seg0_out;\n    logic [6:0]  seg1_out;\n    logic        digit0_enable;\n    logic        digit1_enable;\n\n    // Instantiate DUT\n    seven_seg_mux dut (\n        .clk(clk),\n        .reset_n(reset_n),\n        .digit0_in(digit0_in),\n        .digit1_in(digit1_in),\n        .seg0_out(seg0_out),\n        .seg1_out(seg1_out),\n        .digit0_enable(digit0_enable),\n        .digit1_enable(digit1_enable)\n    );\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    // Test stimulus\n    initial begin\n        reset_n = 0;\n        digit0_in = 4'h0;\n        digit1_in = 4'h0;\n\n        #100 reset_n = 1;\n\n        // Test different digit combinations\n        #1000 digit0_in = 4'h3; digit1_in = 4'h7;\n        #2000 digit0_in = 4'hA; digit1_in = 4'hF;\n        #2000 digit0_in = 4'h5; digit1_in = 4'h2;\n\n        #5000 $finish;\n    end\n\n    // Monitor outputs\n    initial begin\n        $monitor(\"Time=%0t, digit0_in=%h, digit1_in=%h, seg0=%b, seg1=%b, en0=%b, en1=%b\", \n                $time, digit0_in, digit1_in, seg0_out, seg1_out, digit0_enable, digit1_enable);\n    end\n\nendmodule\nNext, I asked the LLM to: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.” and attached my Lab 1 files. I received the following design that, again, did not synthesize.\n// Isabella Hottenrott's segments module\n// segments.sv\n// Module containing Verilog code for Seven-segment display mapping\nmodule segments(input logic [3:0] digit,\n                output logic [6:0] segs);\n\nalways_comb\ncase(digit)\n    0:  segs = 7'b000_0001; //0\n    1:  segs = 7'b100_1111; //1\n    2:  segs = 7'b001_0010; //2\n    3:  segs = 7'b000_0110; //3\n    4:  segs = 7'b100_1100; //4\n    5:  segs = 7'b010_0100; //5\n    6:  segs = 7'b010_0000; //6\n    7:  segs = 7'b000_1111; //7\n    8:  segs = 7'b000_0000; //8\n    9:  segs = 7'b000_1100; // 9\n    10: segs = 7'b000_1000; //a\n    11: segs = 7'b110_0000; //b\n    12: segs = 7'b011_0001; //c\n    13: segs = 7'b100_0010; //d\n    14: segs = 7'b011_0000; //e\n    15: segs = 7'b011_1000; //f\n    default:    segs = 7'b111_1111;\nendcase\nendmodule\n\n// Simple oscillator module for timing control\nmodule oscillator(input logic clk,\n              input logic reset,\n              output logic slow_clk);\n\nparameter DIVIDE_RATIO = 50000; // Adjust for desired refresh rate\nlogic [$clog2(DIVIDE_RATIO)-1:0] counter;\n\nalways_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n        counter &lt;= 0;\n        slow_clk &lt;= 0;\n    end else begin\n        if (counter == DIVIDE_RATIO - 1) begin\n            counter &lt;= 0;\n            slow_clk &lt;= ~slow_clk;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\nend\nendmodule\n\nmodule seven_seg_time_mux(\n    input logic clk,\n    input logic reset,\n    input logic [3:0] digit0,    // First 4-bit input\n    input logic [3:0] digit1,    // Second 4-bit input\n    output logic [6:0] segs0,    // Seven segment outputs for display 0\n    output logic [6:0] segs1     // Seven segment outputs for display 1\n);\n\n// Internal signals\nlogic [3:0] mux_digit;       // Multiplexed input to decoder\nlogic [6:0] decoder_segs;    // Output from segments decoder\nlogic mux_select;            // Select signal for multiplexing\nlogic slow_clk;              // Slower clock for multiplexing\n\n// Instantiate oscillator for timing control\noscillator timing_gen (\n    .clk(clk),\n    .reset(reset),\n    .slow_clk(slow_clk)\n);\n\n// Generate multiplexer select signal (toggles between displays)\nalways_ff @(posedge slow_clk or posedge reset) begin\n    if (reset)\n        mux_select &lt;= 1'b0;\n    else\n        mux_select &lt;= ~mux_select;\nend\n\n// Input multiplexer - select which digit to decode\nalways_comb begin\n    case (mux_select)\n        1'b0: mux_digit = digit0;\n        1'b1: mux_digit = digit1;\n        default: mux_digit = digit0;\n    endcase\nend\n\n// Instantiate Isabella's segments decoder\nsegments decoder (\n    .digit(mux_digit),\n    .segs(decoder_segs)\n);\n\n// Output demultiplexer - route decoder output to appropriate display\n// When a display is not selected, turn off all segments (common anode = all high)\nalways_comb begin\n    case (mux_select)\n        1'b0: begin\n            segs0 = decoder_segs;    // Display digit0\n            segs1 = 7'b111_1111;     // Turn off display 1\n        end\n        1'b1: begin\n            segs0 = 7'b111_1111;     // Turn off display 0\n            segs1 = decoder_segs;    // Display digit1\n        end\n        default: begin\n            segs0 = 7'b111_1111;\n            segs1 = 7'b111_1111;\n        end\n    endcase\nend\nendmodule\nlogic clk;\nlogic reset;\nlogic [3:0] digit0;\nlogic [3:0] digit1;\nlogic [6:0] segs0;\nlogic [6:0] segs1;\n\n// Instantiate the Device Under Test (DUT)\nseven_seg_time_mux dut (\n    .clk(clk),\n    .reset(reset),\n    .digit0(digit0),\n    .digit1(digit1),\n    .segs0(segs0),\n    .segs1(segs1)\n);\n\n// Clock generation (50MHz system clock)\ninitial begin\n    clk = 0;\n    forever #10 clk = ~clk; // 20ns period = 50MHz\nend\n\n// Test stimulus\ninitial begin\n    // Initialize signals\n    reset = 1;\n    digit0 = 4'h0;\n    digit1 = 4'h0;\n    \n    // Release reset\n    #100 reset = 0;\n    \n    // Test case 1: Display 3 and 7\n    #1000 digit0 = 4'h3; digit1 = 4'h7;\n    \n    // Test case 2: Display A and F (hex)\n    #5000 digit0 = 4'hA; digit1 = 4'hF;\n    \n    // Test case 3: Display 5 and 2\n    #5000 digit0 = 4'h5; digit1 = 4'h2;\n    \n    // Test case 4: Display 8 and 1\n    #5000 digit0 = 4'h8; digit1 = 4'h1;\n    \n    // Finish simulation\n    #10000 $finish;\nend\n\n// Monitor key signals\ninitial begin\n    $monitor(\"Time=%0t, digit0=%h, digit1=%h, segs0=%b, segs1=%b\", \n             $time, digit0, digit1, segs0, segs1);\nend\n\n// Generate VCD file for waveform viewing\ninitial begin\n    $dumpfile(\"seven_seg_mux.vcd\");\n    $dumpvars(0, seven_seg_time_mux_tb);\nend\nendmodule\nBoth designs ran into the issue that the “loop count limit [of the clock] exceeded forever never breaks”. This occured because both LLM outputs created associated testbenches. I tried to take out this forever statement, and make the clock tick similarly to my own testbenches. However, when I did this, I received a “Synthesize Design Completed, Lattice Synthesis Engine Failed” error."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "Lab 4: Digital Audio\n\nIntroduction\n\n\nDesign and Testing Methodology\n\n\nTechnical Documentation\n\n\nBlock Diagram\n\n\nSchematic\n\n\nResults and Discussion\n\n\nTestbench Simulation\n\n\nConclusion\n\n\nAI Prototype Summary"
  },
  {
    "objectID": "posts/second-post.html",
    "href": "posts/second-post.html",
    "title": "Blog 1",
    "section": "",
    "text": "As of today, I have completed my first MicroPs lab. Overall, I did not think that the tasks were too challenging. I have PCB assembly experience from my summer internship, and very quickly understood what was needed to be done on the FPGA. That said, I ended up spending around twenty hours working. I did not anticipate some issues, such as missing components and the fact that the software took a very long time to load. However, I learned many lessons about what I will not allow myself to do in the future.\nLesson 1- I was quite absent-minded when configuring my project. I accidentally created a Verilog file instead of a SystemVerilog file, which caused syntax errors and took me around an hour to discover. I also gave my files/modules undescriptive names twice in a row. In order to rename the files, while making sure the whole project/file tree stayed consistent, I had to start a new project. This involved a lot of time wasted waiting for Radiant to power up. I would also often close the Programmer after being thrown the J-Link issue, even though this wasn’t necessary. This meant that I would have to wait for the Programmer to open almost every time I tried to reprogram the FPGA, which always took a while.\nLesson 2- Having my check off on Thursday meant that I was working at a slower and less efficient pace than my peers in lab, because I didn’t have the stress of a near upcoming assignment. I think I spent more time in lab than was necessary, not doing efficient work. As a result, the two nights before my Thursday check-in were longer nights for me.\nI do not feel positively toward how I managed my time and brain resources on this first lab. However, I am foremost taking this as a learning experience. I am happy this happened to me now and made me realize I have to get into shape before more difficult labs come along."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "E155 Course Website\nE155 Github Repository"
  },
  {
    "objectID": "resources.html#portfolio-resources",
    "href": "resources.html#portfolio-resources",
    "title": "Resources",
    "section": "",
    "text": "E155 Course Website\nE155 Github Repository"
  }
]