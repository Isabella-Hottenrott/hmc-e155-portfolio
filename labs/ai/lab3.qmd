## AI Prototype Lab 3

The first prompt that I provided the LLM was a monolithic prompts:      

        "Target device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).

        Write synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement:

        A clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator.
        A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release.
        A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness.
        Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices." 

In return, I recieved the following design linked [here](https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/AI/protoA.sv) that synthesized. 
This verilog produced a design with four FSM states. The instantiation of these states can be seen below. There was no FSM module specifically, and state transitions were scattered throughout the module.
 ![Figure 18: AI Proto A Instantiation of States](../lab3/images/aiA.png){fig-align="center"}
Otherwise, the commented logic provided by the LLM followed a path that made sense. The encodings for the segments were correct.



Next, I prompted the LLM in a modular manner such that it would decompose FSMs.
The first of these prompts was:

        "Target device: Lattice iCE40 UP5K FPGA.

        Overall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display.

        Current Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior:

        When a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse.
        While any key remains pressed, do not accept additional keys.
        Only after keys are released should a subsequent press be recognized.
        This should handle debouncing of the keys.
        Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here."

In return, I recieved the following design linked [here](https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/AI/protoBi.sv) that synthesized. 

The second modular prompt was:
        "Target device: Lattice iCE40 UP5K FPGA.

        Write a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior:

        Iterate columns at a suitable scan rate derived from the divided clock and sample rows.
        When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed.
        Provide a boolean signal indicating whether any key is currently pressed.
        Use clean state encoding and synchronous logic; avoid combinational feedback and latches."

In return, I recieved the following design linked [here](https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/AI/protoBii.sv) that synthesized. 

The design decoded the columns and rows in a case statement, verbosely breaking down every column and row possibility. Immediately, the row and column combinations were converted into the hex value that was pressed.

 ![Figure 19: AI Proto Bii Breakdownof Columns and Rows](../lab3/images/aiBii.png){fig-align="center"}


The final of the modular prompts was:
        "Target device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source.

        Write a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements:

        Update the displayed digits only when a new key is registered.
        Ensure equal apparent brightness and no visible flicker.
        Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs.
        Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments."

In return, I recieved the following design linked [here](https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/AI/protoBiii.sv). 

 ![Figure 20: AI Proto Biii Unsynthesizable Clock](../lab3/images/aiBiii.png){fig-align="center"}

This was the first of the designs returned by the LLM that did not synthesize. Claude attempted to import the wrong High Frequency Oscillator, as shown in the image above.