<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>AI Prototypes for E155 Labs – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs/labs.html"> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../project.html"> 
<span class="menu-text">Project</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../labs/ai/ai.html" aria-current="page"> 
<span class="menu-text">AI Prototypes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#ai-prototype-lab-1" id="toc-ai-prototype-lab-1" class="nav-link active" data-scroll-target="#ai-prototype-lab-1">AI Prototype Lab 1</a></li>
  <li><a href="#ai-prototype-lab-2" id="toc-ai-prototype-lab-2" class="nav-link" data-scroll-target="#ai-prototype-lab-2">AI Prototype Lab 2</a></li>
  <li><a href="#ai-prototype-lab-3" id="toc-ai-prototype-lab-3" class="nav-link" data-scroll-target="#ai-prototype-lab-3">AI Prototype Lab 3</a></li>
  <li><a href="#ai-prototype-lab-4" id="toc-ai-prototype-lab-4" class="nav-link" data-scroll-target="#ai-prototype-lab-4">AI Prototype Lab 4</a></li>
  <li><a href="#ai-prototype-lab-5" id="toc-ai-prototype-lab-5" class="nav-link" data-scroll-target="#ai-prototype-lab-5">AI Prototype Lab 5</a></li>
  <li><a href="#ai-prototype-lab-6" id="toc-ai-prototype-lab-6" class="nav-link" data-scroll-target="#ai-prototype-lab-6">AI Prototype Lab 6</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">AI Prototypes for E155 Labs</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="ai-prototype-lab-1" class="level2">
<h2 class="anchored" data-anchor-id="ai-prototype-lab-1">AI Prototype Lab 1</h2>
<p>The prompt that I provided the LLM was: “Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”</p>
<p>In response, I received:</p>
<pre><code>// Blink an LED at ~2 Hz using the iCE40UP5K internal HFOSC.
// Toolchains: Lattice Radiant/iCEcube2 or open-source (yosys/nextpnr-ice40).

module up5k_led_blink_2hz (
    output logic led_o   // drive your LED pin (active-high assumed)
);

logic clk_12mhz;

SB_HFOSC u_hfosc (
    .CLKHFEN (1'b1),   // enable output (assert after 100 µs PU time)
    .CLKHFPU (1'b1),   // power-up oscillator
    .CLKHF   (clk_12mhz)
);

localparam int unsigned F_CLK_HZ = 12_000_000;
localparam int unsigned F_BLINK_HZ = 2;
localparam int unsigned TICKS_PER_TOGGLE = F_CLK_HZ / (2 * F_BLINK_HZ);

localparam int COUNTER_W = $clog2(TICKS_PER_TOGGLE);
logic [COUNTER_W-1:0] tick_cnt /* synthesis preserve */;

always_ff @(posedge clk_12mhz) begin
    if (tick_cnt == TICKS_PER_TOGGLE-1) begin
        tick_cnt &lt;= '0;
        led_o    &lt;= ~led_o;       // toggle at 2 Hz
    end else begin
        tick_cnt &lt;= tick_cnt + 1;
    end
end

initial led_o = 1'b0;

endmodule</code></pre>
<p>When I attempted to synthesize this design, I thrown the error “instantiating unknown module SB_HFSOSC. VERI-1063”. I typed the error message back into the LLM, and it corrected itself by instantiating the module “SB_HFOSC”. The LLM had falsely named the Lattice iCE40/UP5K primitive of the on-board FPGA.</p>
<p>I would overall rate the quality of the output poorly. I used ChatGPT 5 for this task, and would have expected it to not make such a basic and obvious mistake. The prompt asked to produce a very simple design, so I found it surprising that the LLM’s output didn’t synthesize on the first try. I also found the mistake surprising, because there should be a correlation between “iCE40/UP5K” and “SB_HFOSC”, rather than “SB_HFSOSC” in the data that the chatbot used to create its answer.</p>
<p>Otherwise, the logic that the LLM created made sense, and the chatbot attempted to use local parameters and calculations to arrive at values necessary for the clock division. This makes the design modular.</p>
</section>
<section id="ai-prototype-lab-2" class="level2">
<h2 class="anchored" data-anchor-id="ai-prototype-lab-2">AI Prototype Lab 2</h2>
<p>The prompt that I provided the LLM was: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.” In return, I recieved the following design that did not synthesize:</p>
<pre><code>// Time Multiplexed Seven Segment Display Controller
// This module uses a single seven segment decoder to drive two displays

module seven_seg_mux (
    input  logic        clk,
    input  logic        reset_n,
    input  logic [3:0]  digit0_in,    // First 4-bit input
    input  logic [3:0]  digit1_in,    // Second 4-bit input
    output logic [6:0]  seg0_out,     // Seven segment outputs for display 0
    output logic [6:0]  seg1_out,     // Seven segment outputs for display 1
    output logic        digit0_enable, // Enable signal for display 0
    output logic        digit1_enable  // Enable signal for display 1
);

    // Internal signals
    logic [3:0] mux_input;
    logic [6:0] decoder_output;
    logic       mux_select;
    logic       slow_clk;

    // Instantiate oscillator for timing
    oscillator u_osc (
        .clk(clk),
        .reset_n(reset_n),
        .slow_clk(slow_clk)
    );

    // Generate multiplexer select signal
    always_ff @(posedge slow_clk or negedge reset_n) begin
        if (!reset_n)
            mux_select &lt;= 1'b0;
        else
            mux_select &lt;= ~mux_select;
    end

    // Input multiplexer
    always_comb begin
        case (mux_select)
            1'b0: mux_input = digit0_in;
            1'b1: mux_input = digit1_in;
        endcase
    end

    // Instantiate seven segment decoder
    seven_seg_decoder u_decoder (
        .bin_in(mux_input),
        .seg_out(decoder_output)
    );

    // Output demultiplexer and enable generation
    always_comb begin
        case (mux_select)
            1'b0: begin
                seg0_out = decoder_output;
                seg1_out = 7'b1111111;  // All segments off (common anode)
                digit0_enable = 1'b0;   // Active low enable
                digit1_enable = 1'b1;   // Disabled
            end
            1'b1: begin
                seg0_out = 7'b1111111;  // All segments off
                seg1_out = decoder_output;
                digit0_enable = 1'b1;   // Disabled
                digit1_enable = 1'b0;   // Active low enable
            end
        endcase
    end

endmodule

// Seven Segment Decoder Module
// Converts 4-bit binary input to seven segment display pattern
// Common anode configuration (active low outputs)
module seven_seg_decoder (
    input  logic [3:0] bin_in,
    output logic [6:0] seg_out
);

    // Segment mapping: seg_out = {g, f, e, d, c, b, a}
    // Common anode: 0 = segment on, 1 = segment off
    always_comb begin
        case (bin_in)
            4'h0: seg_out = 7'b1000000; // 0
            4'h1: seg_out = 7'b1111001; // 1
            4'h2: seg_out = 7'b0100100; // 2
            4'h3: seg_out = 7'b0110000; // 3
            4'h4: seg_out = 7'b0011001; // 4
            4'h5: seg_out = 7'b0010010; // 5
            4'h6: seg_out = 7'b0000010; // 6
            4'h7: seg_out = 7'b1111000; // 7
            4'h8: seg_out = 7'b0000000; // 8
            4'h9: seg_out = 7'b0010000; // 9
            4'hA: seg_out = 7'b0001000; // A
            4'hB: seg_out = 7'b0000011; // b
            4'hC: seg_out = 7'b1000110; // C
            4'hD: seg_out = 7'b0100001; // d
            4'hE: seg_out = 7'b0000110; // E
            4'hF: seg_out = 7'b0001110; // F
        endcase
    end

endmodule

// Simple Oscillator Module
// Generates a slower clock for multiplexing
module oscillator (
    input  logic clk,
    input  logic reset_n,
    output logic slow_clk
);

    parameter DIVIDE_BY = 100000; // Adjust for desired refresh rate
    logic [$clog2(DIVIDE_BY)-1:0] counter;

    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            counter &lt;= '0;
            slow_clk &lt;= 1'b0;
        end else begin
            if (counter == DIVIDE_BY - 1) begin
                counter &lt;= '0;
                slow_clk &lt;= ~slow_clk;
            end else begin
                counter &lt;= counter + 1;
            end
        end
    end

endmodule

// Testbench for verification
module seven_seg_mux_tb;

    logic        clk;
    logic        reset_n;
    logic [3:0]  digit0_in;
    logic [3:0]  digit1_in;
    logic [6:0]  seg0_out;
    logic [6:0]  seg1_out;
    logic        digit0_enable;
    logic        digit1_enable;

    // Instantiate DUT
    seven_seg_mux dut (
        .clk(clk),
        .reset_n(reset_n),
        .digit0_in(digit0_in),
        .digit1_in(digit1_in),
        .seg0_out(seg0_out),
        .seg1_out(seg1_out),
        .digit0_enable(digit0_enable),
        .digit1_enable(digit1_enable)
    );

    // Clock generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    // Test stimulus
    initial begin
        reset_n = 0;
        digit0_in = 4'h0;
        digit1_in = 4'h0;

        #100 reset_n = 1;

        // Test different digit combinations
        #1000 digit0_in = 4'h3; digit1_in = 4'h7;
        #2000 digit0_in = 4'hA; digit1_in = 4'hF;
        #2000 digit0_in = 4'h5; digit1_in = 4'h2;

        #5000 $finish;
    end

    // Monitor outputs
    initial begin
        $monitor("Time=%0t, digit0_in=%h, digit1_in=%h, seg0=%b, seg1=%b, en0=%b, en1=%b", 
                $time, digit0_in, digit1_in, seg0_out, seg1_out, digit0_enable, digit1_enable);
    end

endmodule</code></pre>
<p>Next, I asked the LLM to: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.” and attached my Lab 1 files. I received the following design that, again, did not synthesize.</p>
<pre><code>// Isabella Hottenrott's segments module
// segments.sv
// Module containing Verilog code for Seven-segment display mapping
module segments(input logic [3:0] digit,
                output logic [6:0] segs);

always_comb
case(digit)
    0:  segs = 7'b000_0001; //0
    1:  segs = 7'b100_1111; //1
    2:  segs = 7'b001_0010; //2
    3:  segs = 7'b000_0110; //3
    4:  segs = 7'b100_1100; //4
    5:  segs = 7'b010_0100; //5
    6:  segs = 7'b010_0000; //6
    7:  segs = 7'b000_1111; //7
    8:  segs = 7'b000_0000; //8
    9:  segs = 7'b000_1100; // 9
    10: segs = 7'b000_1000; //a
    11: segs = 7'b110_0000; //b
    12: segs = 7'b011_0001; //c
    13: segs = 7'b100_0010; //d
    14: segs = 7'b011_0000; //e
    15: segs = 7'b011_1000; //f
    default:    segs = 7'b111_1111;
endcase
endmodule

// Simple oscillator module for timing control
module oscillator(input logic clk,
              input logic reset,
              output logic slow_clk);

parameter DIVIDE_RATIO = 50000; // Adjust for desired refresh rate
logic [$clog2(DIVIDE_RATIO)-1:0] counter;

always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        counter &lt;= 0;
        slow_clk &lt;= 0;
    end else begin
        if (counter == DIVIDE_RATIO - 1) begin
            counter &lt;= 0;
            slow_clk &lt;= ~slow_clk;
        end else begin
            counter &lt;= counter + 1;
        end
    end
end
endmodule

module seven_seg_time_mux(
    input logic clk,
    input logic reset,
    input logic [3:0] digit0,    // First 4-bit input
    input logic [3:0] digit1,    // Second 4-bit input
    output logic [6:0] segs0,    // Seven segment outputs for display 0
    output logic [6:0] segs1     // Seven segment outputs for display 1
);

// Internal signals
logic [3:0] mux_digit;       // Multiplexed input to decoder
logic [6:0] decoder_segs;    // Output from segments decoder
logic mux_select;            // Select signal for multiplexing
logic slow_clk;              // Slower clock for multiplexing

// Instantiate oscillator for timing control
oscillator timing_gen (
    .clk(clk),
    .reset(reset),
    .slow_clk(slow_clk)
);

// Generate multiplexer select signal (toggles between displays)
always_ff @(posedge slow_clk or posedge reset) begin
    if (reset)
        mux_select &lt;= 1'b0;
    else
        mux_select &lt;= ~mux_select;
end

// Input multiplexer - select which digit to decode
always_comb begin
    case (mux_select)
        1'b0: mux_digit = digit0;
        1'b1: mux_digit = digit1;
        default: mux_digit = digit0;
    endcase
end

// Instantiate Isabella's segments decoder
segments decoder (
    .digit(mux_digit),
    .segs(decoder_segs)
);

// Output demultiplexer - route decoder output to appropriate display
// When a display is not selected, turn off all segments (common anode = all high)
always_comb begin
    case (mux_select)
        1'b0: begin
            segs0 = decoder_segs;    // Display digit0
            segs1 = 7'b111_1111;     // Turn off display 1
        end
        1'b1: begin
            segs0 = 7'b111_1111;     // Turn off display 0
            segs1 = decoder_segs;    // Display digit1
        end
        default: begin
            segs0 = 7'b111_1111;
            segs1 = 7'b111_1111;
        end
    endcase
end</code></pre>
<p>endmodule</p>
<pre><code>logic clk;
logic reset;
logic [3:0] digit0;
logic [3:0] digit1;
logic [6:0] segs0;
logic [6:0] segs1;

// Instantiate the Device Under Test (DUT)
seven_seg_time_mux dut (
    .clk(clk),
    .reset(reset),
    .digit0(digit0),
    .digit1(digit1),
    .segs0(segs0),
    .segs1(segs1)
);

// Clock generation (50MHz system clock)
initial begin
    clk = 0;
    forever #10 clk = ~clk; // 20ns period = 50MHz
end

// Test stimulus
initial begin
    // Initialize signals
    reset = 1;
    digit0 = 4'h0;
    digit1 = 4'h0;
    
    // Release reset
    #100 reset = 0;
    
    // Test case 1: Display 3 and 7
    #1000 digit0 = 4'h3; digit1 = 4'h7;
    
    // Test case 2: Display A and F (hex)
    #5000 digit0 = 4'hA; digit1 = 4'hF;
    
    // Test case 3: Display 5 and 2
    #5000 digit0 = 4'h5; digit1 = 4'h2;
    
    // Test case 4: Display 8 and 1
    #5000 digit0 = 4'h8; digit1 = 4'h1;
    
    // Finish simulation
    #10000 $finish;
end

// Monitor key signals
initial begin
    $monitor("Time=%0t, digit0=%h, digit1=%h, segs0=%b, segs1=%b", 
             $time, digit0, digit1, segs0, segs1);
end

// Generate VCD file for waveform viewing
initial begin
    $dumpfile("seven_seg_mux.vcd");
    $dumpvars(0, seven_seg_time_mux_tb);
end</code></pre>
<p>endmodule</p>
<p>Both designs ran into the issue that the “loop count limit [of the clock] exceeded forever never breaks”. This occured because both LLM outputs created associated testbenches. I tried to take out this forever statement, and make the clock tick similarly to my own testbenches. However, when I did this, I received a “Synthesize Design Completed, Lattice Synthesis Engine Failed” error.</p>
</section>
<section id="ai-prototype-lab-3" class="level2">
<h2 class="anchored" data-anchor-id="ai-prototype-lab-3">AI Prototype Lab 3</h2>
<p>The first prompt that I provided the LLM was a monolithic prompts:</p>
<pre><code>    "Target device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).

    Write synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement:

    A clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator.
    A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release.
    A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness.
    Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices." </code></pre>
<p>In return, I recieved the following design linked <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/AI/protoA.sv">here</a> that synthesized. This verilog produced a design with four FSM states. The instantiation of these states can be seen below. There was no FSM module specifically, and state transitions were scattered throughout the module. <img src="../lab3/images/aiA.png" class="img-fluid quarto-figure quarto-figure-center" alt="Figure 18: AI Proto A Instantiation of States"></p>
<p>Otherwise, the commented logic provided by the LLM followed a path that made sense. The encodings for the segments were correct.</p>
<p>Next, I prompted the LLM in a modular manner such that it would decompose FSMs. The first of these prompts was:</p>
<pre><code>    "Target device: Lattice iCE40 UP5K FPGA.

    Overall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display.

    Current Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior:

    When a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse.
    While any key remains pressed, do not accept additional keys.
    Only after keys are released should a subsequent press be recognized.
    This should handle debouncing of the keys.
    Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here."</code></pre>
<p>In return, I recieved the following design linked <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/AI/protoBi.sv">here</a> that synthesized.</p>
<p>The second modular prompt was: “Target device: Lattice iCE40 UP5K FPGA.</p>
<pre><code>    Write a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior:

    Iterate columns at a suitable scan rate derived from the divided clock and sample rows.
    When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed.
    Provide a boolean signal indicating whether any key is currently pressed.
    Use clean state encoding and synchronous logic; avoid combinational feedback and latches."</code></pre>
<p>In return, I recieved the following design linked <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/AI/protoBii.sv">here</a> that synthesized.</p>
<p>The design decoded the columns and rows in a case statement, verbosely breaking down every column and row possibility. Immediately, the row and column combinations were converted into the hex value that was pressed.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../lab3/images/aiBii.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19: AI Proto Bii Breakdownof Columns and Rows</figcaption>
</figure>
</div>
<p>The final of the modular prompts was: “Target device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source.</p>
<pre><code>    Write a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements:

    Update the displayed digits only when a new key is registered.
    Ensure equal apparent brightness and no visible flicker.
    Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs.
    Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments."</code></pre>
<p>In return, I recieved the following design linked <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/AI/protoBiii.sv">here</a>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../lab3/images/aiBiii.png" class="img-fluid figure-img"></p>
<figcaption>Figure 20: AI Proto Biii Unsynthesizable Clock</figcaption>
</figure>
</div>
<p>This was the first of the designs returned by the LLM that did not synthesize. Claude attempted to import the wrong High Frequency Oscillator, as shown in the image above.</p>
</section>
<section id="ai-prototype-lab-4" class="level2">
<h2 class="anchored" data-anchor-id="ai-prototype-lab-4">AI Prototype Lab 4</h2>
<p>I prompted the following LLM with the question:</p>
<p>What timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?</p>
<p>It responded:</p>
<pre><code>TIM2 (32-bit general-purpose) — easiest and most flexible choice. It has multiple channel outputs you can route to GPIO pins (e.g., PA0/PA5/PA15 → TIM2_CH1 (AF1), PB3 → TIM2_CH2 (AF1), etc.).  ￼
TIM1 / TIM15–17 (16-bit) — also fine for PWM; TIM1 is “advanced” (needs MOE bit set) but you don’t need advanced features for simple tones. Device includes 1× advanced, 2× GP16, 1× GP32 per datasheet.  ￼
LPTIM1 / LPTIM2 (low-power timers) — great if you want the signal to keep running in Stop modes or be clocked from LSE/LSI, and they have an OUT pin you can map (e.g., PA4/PA8 → LPTIM2_OUT (AF14)). For simple “always-on” PWM they work well too.  ￼

Best simple choice for GPIO: TIM2 — 32-bit (so huge range/resolution), plentiful pin options (AF1 on several pins), and zero “advanced timer” gotchas.</code></pre>
<p>Overall, the datasheet got the explicitly-mentioned functionalities of the onboard timer right. For the specific application, it was wrong in deciding that 32 bits would be necessary. It did not include configurations to the RCC that need to be made for the Timers. It also forgot to add anything about registers or calculations for the actual clock division. The LLM also pointed toward the low-power timers. This is not unreasonable, because it wasn’t given any information on how long the timers would be active vs idle. After providing the LLM with the Reference Manual, it reaffirmed the decision to use Timer 2. Overall, I think going through the reference manual on my own is still a better use of time than taking the LLM output and debugging. I was a bit surprised about this, because I feel that there is enough online documentation for the LLM to output a more detailed response.</p>
</section>
<section id="ai-prototype-lab-5" class="level2">
<h2 class="anchored" data-anchor-id="ai-prototype-lab-5">AI Prototype Lab 5</h2>
<p>I prompted ChatGPT5 with the following: “Write me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?”</p>
<p>In response, it provided me with the following:</p>
<pre><code>    "// Globals
    static volatile int32_t encoder_count = 0;
    static volatile uint8_t prev_state = 0;

    // Call this during init (after HAL_Init and clocks).
    static void Encoder_EXTI_Init(void) {
        __HAL_RCC_GPIOA_CLK_ENABLE();

        gi.Mode  = GPIO_MODE_IT_RISING_FALLING;  // fire on both edges
        gi.Pull  = GPIO_PULLUP;                  // or GPIO_NOPULL if you have externals
        gi.Speed = GPIO_SPEED_FREQ_LOW;

        // Using PA0 (A) and PA1 (B). Change to whatever pins you chose.
        gi.Pin = GPIO_PIN_0 | GPIO_PIN_1;
        HAL_GPIO_Init(GPIOA, &amp;gi);

        // Read initial state
        uint8_t a = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) ? 1 : 0;
        uint8_t b = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1) ? 1 : 0;
        prev_state = (a &lt;&lt; 1) | b;

        // Enable EXTI lines NVIC (EXTI0 for PA0, EXTI1 for PA1)
        HAL_NVIC_SetPriority(EXTI0_IRQn, 5, 0);
        HAL_NVIC_EnableIRQ(EXTI0_IRQn);

        HAL_NVIC_SetPriority(EXTI1_IRQn, 5, 0);
        HAL_NVIC_EnableIRQ(EXTI1_IRQn);
    } 
    
    // Returns +1, -1, or 0 based on transition
        static inline int8_t quad_step(uint8_t prev, uint8_t next) {
            // Index  (prev&lt;&lt;2)|next, values: 0, +1, -1, etc.
            static const int8_t lut[16] = {
                0,  +1,  -1,   0,
                -1,  0,   0,  +1,
                +1,  0,   0,  -1,
                0,  -1,  +1,   0
            };
            return lut[(prev &lt;&lt; 2) | next];
        }

        static inline void Encoder_EXTI_Service(void) {
            uint8_t a = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) ? 1 : 0;
            uint8_t b = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1) ? 1 : 0;
            uint8_t next = (a &lt;&lt; 1) | b;

            int8_t d = quad_step(prev_state, next);
            prev_state = next;
            encoder_count += d;
        }

        // IRQs (CubeMX names)
        void EXTI0_IRQHandler(void) {
            HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
        }
        void EXTI1_IRQHandler(void) {
            HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_1);
        }

        void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
            if (GPIO_Pin == GPIO_PIN_0 || GPIO_Pin == GPIO_PIN_1) {
                Encoder_EXTI_Service();
            }
        }"</code></pre>
<p>This code did not compile. I pasted some of the errors in, and the chatpot responded that it forgot to add in the line:</p>
<pre><code>    "GPIO_InitTypeDef gi = {0};"
    </code></pre>
<p>The definition of gi is necessary; without it, there is no valid gi object for the code to configure, so those member accesses would always fail. This addition still didnt compile.</p>
<p>The next issue was that the chatbot had not included the appropriate HAL GPIO header file. In order for both GPIO_InitTypeDef and the various HAL GPIO functions and macros (such as HAL_GPIO_Init, HAL_GPIO_ReadPin, and the GPIO_PIN_x definitions) to be recognized, the code needs an explicit include, for example:</p>
<pre><code>    "#include stm32l4xx_hal_gpio.h"</code></pre>
<p>I was a bit surprised by these omissions in the generated code, since they are fairly fundamental to getting a basic STM32 HAL example to compile. In hindsight, though, I suspect the chatbot simply assumed that I already had the standard STM32 HAL headers included elsewhere in my project and was only trying to illustrate the interrupt-handling and quadrature-decoding logic itself, rather than providing a completely drop-in, self-contained code snippet.</p>
</section>
<section id="ai-prototype-lab-6" class="level2">
<h2 class="anchored" data-anchor-id="ai-prototype-lab-6">AI Prototype Lab 6</h2>
<p>I asked Gemini the prompt: I’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.</p>
<p>It responded:</p>
<pre><code>    &lt;!DOCTYPE html&gt;
    &lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;title&gt;Temperature Sensor Portal&lt;/title&gt;
        
        &lt;style&gt;
            /* --- General Styling --- */
            body {
                font-family: 'Arial', sans-serif;
                background-color: #f0f2f5;
                display: flex;
                justify-content: center;
                align-items: flex-start;
                min-height: 100vh;
                margin: 0;
                padding-top: 50px;
            }

            .container {
                background-color: #ffffff;
                padding: 30px;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                width: 100%;
                max-width: 400px;
                text-align: center;
            }

            h1 {
                color: #333;
                margin-bottom: 30px;
                font-size: 1.8em;
                border-bottom: 2px solid #eee;
                padding-bottom: 10px;
            }
            
            /* --- Temperature Display --- */
            #temperature-display {
                font-size: 4em;
                font-weight: bold;
                color: #d9534f; /* Warm color for temperature */
                margin-bottom: 20px;
            }

            .unit {
                font-size: 0.5em;
                vertical-align: top;
                display: inline-block;
                margin-left: 5px;
            }

            /* --- Control Section --- */
            .control-group {
                margin-top: 25px;
                padding: 15px;
                border: 1px solid #ddd;
                border-radius: 8px;
                text-align: left;
            }
            
            .control-group h3 {
                margin-top: 0;
                color: #555;
                font-size: 1.1em;
                border-bottom: 1px solid #eee;
                padding-bottom: 8px;
                margin-bottom: 15px;
            }

            .control-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
            }

            .control-item:last-child {
                margin-bottom: 0;
            }

            /* --- LED Control Button --- */
            #led-button {
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-weight: bold;
                transition: background-color 0.3s, box-shadow 0.3s;
            }

            .led-on {
                background-color: #5cb85c; /* Green */
                color: white;
                box-shadow: 0 2px 4px rgba(92, 184, 92, 0.4);
            }

            .led-off {
                background-color: #f0ad4e; /* Orange */
                color: white;
                box-shadow: 0 2px 4px rgba(240, 173, 78, 0.4);
            }

            #led-button:hover {
                opacity: 0.9;
            }

            /* --- Precision Control --- */
            #precision-select {
                padding: 8px;
                border-radius: 5px;
                border: 1px solid #ccc;
                background-color: #f9f9f9;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;

    &lt;div class="container"&gt;
        &lt;h1&gt;Web Sensor Interface&lt;/h1&gt;

        &lt;div class="data-display"&gt;
            &lt;h2&gt;Current Temperature&lt;/h2&gt;
            &lt;div id="temperature-display"&gt;
                24&lt;span class="unit"&gt;.50°C&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;hr&gt;
        
        &lt;div class="control-group"&gt;
            &lt;h3&gt;Device Controls&lt;/h3&gt;

            &lt;div class="control-item"&gt;
                &lt;span&gt;**LED Status:**&lt;/span&gt;
                &lt;button id="led-button" class="led-off"&gt;Turn ON&lt;/button&gt;
            &lt;/div&gt;

            &lt;div class="control-item"&gt;
                &lt;span&gt;**Readout Precision:**&lt;/span&gt;
                &lt;select id="precision-select" onchange="updateTemperature(currentTemp)"&gt;
                    &lt;option value="0"&gt;0 Decimal (25°C)&lt;/option&gt;
                    &lt;option value="1"&gt;1 Decimal (24.5°C)&lt;/option&gt;
                    &lt;option value="2" selected&gt;2 Decimals (24.50°C)&lt;/option&gt;
                    &lt;option value="3"&gt;3 Decimals (24.500°C)&lt;/option&gt;
                &lt;/select&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // --- Global State ---
        let isLedOn = false;
        let currentTemp = 24.505; // Placeholder for the full temperature value

        // --- DOM Elements ---
        const tempDisplay = document.getElementById('temperature-display');
        const ledButton = document.getElementById('led-button');
        const precisionSelect = document.getElementById('precision-select');

        // --- Functions ---

        /**
        * Toggles the LED state (simulated).
        * In a real application, this would send an AJAX/Fetch request to your sensor's backend.
        */
        function toggleLed() {
            isLedOn = !isLedOn;
            if (isLedOn) {
                ledButton.textContent = 'Turn OFF';
                ledButton.classList.remove('led-off');
                ledButton.classList.add('led-on');
                console.log("LED turned ON. (Simulated backend call)");
                // Real code: fetch('/api/led/on');
            } else {
                ledButton.textContent = 'Turn ON';
                ledButton.classList.remove('led-on');
                ledButton.classList.add('led-off');
                console.log("LED turned OFF. (Simulated backend call)");
                // Real code: fetch('/api/led/off');
            }
        }
        
        /**
        * Updates the temperature display based on the selected precision.
        * @param {number} temp - The raw temperature value.
        */
        function updateTemperature(temp) {
            const precision = parseInt(precisionSelect.value);
            const parts = temp.toFixed(precision).split('.');
            
            // Handle case where precision is 0 (no decimal part)
            const integerPart = parts[0];
            const decimalPart = parts.length &gt; 1 ? '.' + parts[1] : '';

            tempDisplay.innerHTML = `${integerPart}&lt;span class="unit"&gt;${decimalPart}°C&lt;/span&gt;`;
        }

        /**
        * Simulates fetching new sensor data and updates the display.
        * In a real application, this would run periodically via setInterval or WebSockets.
        */
        function fetchNewTemperature() {
            // In a real app, you'd use fetch:
            // fetch('/api/temperature').then(res =&gt; res.json()).then(data =&gt; { currentTemp = data.temp; updateTemperature(currentTemp); });

            // For this example, let's simulate a minor temp change:
            currentTemp = 24.505 + (Math.random() - 0.5) / 10; // Small random fluctuation
            updateTemperature(currentTemp);
        }


        // --- Event Listeners and Initial Setup ---
        
        // 1. LED Button
        ledButton.addEventListener('click', toggleLed);

        // 2. Initial Temperature Display
        updateTemperature(currentTemp);

        // 3. Simulated Live Update (fetches new temp every 5 seconds)
        setInterval(fetchNewTemperature, 5000); // Poll every 5 seconds (adjust as needed)

    &lt;/script&gt;

    &lt;/body&gt;
    &lt;/html&gt;</code></pre>
<p>Next, I asked: Write me a C function to carry out a SPI transaction to retrieve a temperature reading from a DS1722 sensor. Make use of CMSIS libraries for the STM32L432KC.</p>
<p>It responded:</p>
<pre><code>    #include "ds1722.h"
    #include &lt;stdint.h&gt;

    /**
    * @brief Performs an SPI transaction to read the temperature from the DS1722 sensor.
    * * The DS1722 expects a 1-byte read command (0x01) followed by 2 bytes of data 
    * which contain the 16-bit two's complement temperature value. The LSB is 1/128 °C.
    * * @param None
    * @return The temperature reading in degrees Celsius (float).
    */
    float DS1722_ReadTemperature(void)
    {
        // The transaction requires 1 byte for the command (0x01) followed by 2 bytes
        // of dummy data to clock out the 16-bit temperature from the sensor.
        uint8_t tx_buffer[3] = {DS1722_CMD_READ_TEMP, 0xFF, 0xFF};
        uint8_t rx_buffer[3] = {0};
        
        int16_t raw_temperature = 0;
        float temperature_celsius = 0.0f;

        // 1. Activate Chip Select (CS low)
        HAL_GPIO_WritePin(DS1722_CS_GPIO_PORT, DS1722_CS_PIN, GPIO_PIN_RESET);

        // 2. Transmit the command byte and simultaneously receive the data bytes.
        // The total transfer length is 3 bytes (Command + MSB Data + LSB Data).
        HAL_StatusTypeDef status = HAL_SPI_TransmitReceive(
            &amp;DS1722_hspi, 
            tx_buffer, 
            rx_buffer, 
            3, 
            HAL_MAX_DELAY
        );

        // 3. Deactivate Chip Select (CS high)
        HAL_GPIO_WritePin(DS1722_CS_GPIO_PORT, DS1722_CS_PIN, GPIO_PIN_SET);

        // Check for successful transmission
        if (status != HAL_OK)
        {
            // Handle error: return a distinct error value or log the issue
            // For simplicity, we return a very low value.
            return -999.0f; 
        }

        /* * The temperature data is returned in rx_buffer[1] (MSB) and rx_buffer[2] (LSB).
        * The MSB is received first.
        * Raw data format: [S S S S S S S S | D D D D D D D D]
        * MSB (rx_buffer[1]) holds the high 8 bits.
        * LSB (rx_buffer[2]) holds the low 8 bits.
        * The LSB is bit D7 (1/128 degree Celsius).
        */
        
        // Combine the 2 received bytes into a 16-bit signed integer (Two's complement)
        raw_temperature = (int16_t)((rx_buffer[1] &lt;&lt; 8) | rx_buffer[2]);

        // 4. Convert the raw two's complement value to Celsius.
        // The resolution is 1/128 °C (0.0078125 °C) per LSB.
        temperature_celsius = (float)raw_temperature / 128.0f;

        return temperature_celsius;
    }</code></pre>
<p>The HTML production was successful and impressive. However, the C code did the wrong temperature conversion, multiplying the LSB by 1/128 instead of 1/16. The C function it produced for reading from the DS1722 sensor looked structurally correct at first glance: it wrapped the SPI transaction properly, used the HAL/CMSIS conventions correctly, handled chip-select sequencing, and even included basic error handling. However, once I compared the code’s data interpretation logic with the DS1722 datasheet, it became clear that the chatbot had misrepresented a core part of the temperature conversion formula. This highlights a general trend when using LLMs for embedded development: they are quite good at scaffolding boilerplate structure and recalling common HAL usage patterns, but any sensor-specific constants, timing rules, or register interpretations still need to be verified against the manufacturer documentation.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/Isabella-Hottenrott\.github\.io\/hmc-e155-portfolio\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>