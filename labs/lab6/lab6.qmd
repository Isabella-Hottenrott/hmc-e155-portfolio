# Lab 6: The Internet of Things and Serial Peripheral Interface


### Introduction

In this lab, an IoT device was implemented and used to control an LED, as well as read temperatures at a user-selected bit-granularity of the temperature sensor. An ESP8266 WiFi dev board was used, along with arduino code to host the web server, and HTML generated by the MCU to host the web page. The temperature sensor used in this design is the DS1722 Digital Thermometer. UART communication was set up between the MCU and ESP8266, while the digital thermometer spoke with the MCU over SPI. This lab required that the SPI driver uses CMSIS templates, which this design implements.

The webpage produced by the HTML code allows for a user to control the status of an on-board LED. The status of the LED is simultaneously correctly reported on the page. The page also allows a user to select whether the temperature sensor measures temperature at 8-, 9-, 10-, 11-, or 12-bit granularity. The bit granularity implemented at the time is correctly reported on the webpage, and the temperature readings demonstrate changes in bit-granularity by an increase in significant digits at higher granularity. Finally, the temperature presently measured by the sensor is reported in degrees Celsius on the page. Temperature readings are updated any time the page is refreshed, or any time a Request is sent following a change in user-control options. 

### Design and Testing Methodology

Once SPI communication was understood and the datasheet was read through, an implementation for the SPI driver was written out. This design required full duplex communication, and only one peripheral to talk to. Therefore, selecting a peripheral was a trivial task, and a GPIO pin was used on the chip enable line. 

The temperature sensor needd to first be initialized by writing the proper configuration to the address 0x80. A single-byte write required the read address, followed by the data byte, to be written to the sensor throug its SDI line. On the other hand, a single-byte read required the read address to be written to the temperature on the SDI pin. The SDO pin would immediately after respond with the data byte. The single-byte reads were executed when reading the temperature sensor, as the sensor was configured in the one-shot configuration, instead of constant conversion.

Any time a new request was sent from the webpage, the configuration and sensor-reading functions were executed in C.

Every single byte write or single byte read was encased in an assertion and deassertion of the chip enable bit, writing this bit HIGH from the GPIO.

The singly byte reads for temperature had to access the 0x02 and 0x01 registers to read the MSB > 0 (0x02) and LSB < 0 (0x01) components of the two's complement representation produced by the sensor. 

### Technical Documentation

The Rx and Tx lines for UART communication used pins in GPIO port A. To avoid any potential interference between the two communication protocols, GPIO port B was enabled and utilized for PSI communication.

To verify that the configuration register was being accessed, and that SPI communciation was functional in the first place, the configuration register was read back after being written. A logical analyzer trace for this can be seen below. The first two bytes represent the configuration address and the proper configuration being written to the sensor, so the MISO output is irrelevant. The third byte represents the configuration read address being written to the sensor, so once again the MISO output is irrelevant. The final byte represents the configuration being written out from the temperature sensor, so the MOSI output is now irrelevant. As seen, the byte read out by the temperature sensor matches what was written two bytes prior.

![Figure 0: SPI Transaction](images/spitransaction.png){fig-align="center"}

In order to convert the dual-register, signed two's complement representation of temperature into a decimal value that would properly convert negative numbers and significant figures, the values extracted from the registers were manipulated. The MSB was shifted right by 8 to discard the fractional bits returned by the read temperature function. The fractional bits were similarly extracted and multiplied by 1/16 to produce the proper fractional representation, since at 12-bit resolution, the LSB could measure up to 1/(2^4) = 1/16.
The sum of these were then calculated, and cast into a float. This was then printed on the webpage.
To verify that negative temperatures could be handled, since no negative ambient temperatures could be reproduced, back calculations for the register-level representations of negative temperatures were made. These were then fed into the converting code, and proved to successfully print out negative values. 

### Schematic

The below schematic was implemented onto a breadboard for this design. 

![Figure 1: Schematic](images/schematic.png){fig-align="center"}

### Results and Discussion

This project successfully demonstrated SPI communication, as well as the ability of embedded devices to communicate with a server and digitize sensor data or other similar information.

### Conclusion
This design was a successful implementation of SPI and UART communication, as well as the development of an IoT device. There was responsive and accurate communication between the temperature sensor, MCU, WiFi dev board, and webpage. This lab took me 12 hours. 


### AI Prototype Summary