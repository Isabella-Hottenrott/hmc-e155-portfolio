# Lab 6: The Internet of Things and Serial Peripheral Interface


### Introduction
In this lab, an IoT device was implemented to control an LED and read temperature measurements from a DS1722 digital thermometer at a user-selectable resolution. An ESP8266 WiFi development board hosted a webpage generated by the MCU. The webpage allowed the user to:

	•	Toggle an on-board LED
	•	Select the temperature sensor’s resolution (8–12 bits)
	•	View the current temperature reading in °C

Communication between the MCU and ESP8266 occurred over UART, while the MCU communicated with the DS1722 thermometer via SPI.

The webpage accurately reflected the LED state and selected bit-resolution, and temperature readings updated on each page refresh or after any user action that generated a new request.

### Design and Testing Methodology

A full-duplex SPI driver was developed using CMSIS. Since only a single SPI peripheral was required, chip-select management was simple and implemented using a dedicated GPIO pin.

The DS1722 must be configured before use by writing the appropriate control byte to register 0x80. A single-byte write involved sending the write address followed by the configuration byte over the SDI line.
For single-byte reads, the MCU first wrote the read address (e.g., 0x01 or 0x02) to the sensor, then clocked out the data returned on the SDO line. The sensor was operated in one-shot conversion mode, so a read produced a fresh measurement each time.

Every SPI access—read or write—was wrapped with chip-select assertion and deassertion using a GPIO pin.

Temperature reads required combining the MSB and LSB registers, where MSB stored the signed integer portion of the temperature (0x02) and LSB stored 4 bits of fractional data at 12-bit resolution (0x01). The DS1722 outputs temperature in signed two’s complement form. The MSB was right-shifted by 8 bits to isolate the integer portion, while the fractional bits were extracted from the LSB and multiplied by 0.0625. These values were added, cast to a float, and printed to the webpage.

Negative temperature readings were validated by manually generating two’s-complement register values and confirming that the conversion logic produced the correct negative result.


### Technical Documentation

UART communication used GPIO Port A pins for TX and RX. To avoid conflicts between protocols, GPIO Port B was dedicated entirely to SPI (SCK, COPI, CIPO, chip-select).

To validate that SPI writes and reads were functioning, the DS1722 configuration register was written and then read back. A logic analyzer trace is shown below. 

![Figure 0: SPI Transaction](images/spitransaction.png){fig-align="center"}

The figure shows a write to and read of the configuration register on the COPI line. Write: Byte 0 is Config Address, Byte 1 is Config Data. Read: Byte 2 is read address, Byte 3 is returned Config Data (on the CIPO line). The returned byte correctly matched the value written earlier, confirming proper SPI operation.

Temperature conversion required combining integer and fractional parts from the MSB and LSB registers. At 12-bit resolution:

The LSB represents fractions of 0.0625 degrees.

The MSB contains the signed integer temperature.

These components were combined and formatted into a decimal string for webpage display.
To validate handling of negative values, synthetic MSB/LSB combinations corresponding to negative temperatures were constructed. When provided to the conversion code, these correctly produced negative decimal values.

### Schematic

The circuit below shows the full hardware implementation. A low-pass filter was added to the CIPO line to mitigate observed clock-coupling noise.

![Figure 1: Schematic](images/schematic.png){fig-align="center"}

### Results and Discussion

This project successfully demonstrated SPI and UART communication, dynamic webpage generation, user adjustable resolution settings, and real-time temperature reporting through an IoT interface.

### Conclusion
This lab produced a robust IoT device that integrated SPI, UART, and webserver functionality. The temperature sensor, MCU, WiFi module, and browser interface communicated seamlessly, demonstrating a complete end-to-end embedded system. The design was responsive, accurate, and easy to extend with additional controls or sensors.


### AI Prototype Summary

I asked Gemini the prompt:
I’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.

The LLM's response, as well as my evaluation of the response, can be found [here](../ai/ai.qmd)
