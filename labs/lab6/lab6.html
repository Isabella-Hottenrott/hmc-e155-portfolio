<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>lab6 – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs/labs.html"> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../project.html"> 
<span class="menu-text">Project</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#lab-6-the-internet-of-things-and-serial-peripheral-interface" id="toc-lab-6-the-internet-of-things-and-serial-peripheral-interface" class="nav-link active" data-scroll-target="#lab-6-the-internet-of-things-and-serial-peripheral-interface">Lab 6: The Internet of Things and Serial Peripheral Interface</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#design-and-testing-methodology" id="toc-design-and-testing-methodology" class="nav-link" data-scroll-target="#design-and-testing-methodology">Design and Testing Methodology</a></li>
  <li><a href="#technical-documentation" id="toc-technical-documentation" class="nav-link" data-scroll-target="#technical-documentation">Technical Documentation</a></li>
  <li><a href="#schematic" id="toc-schematic" class="nav-link" data-scroll-target="#schematic">Schematic</a></li>
  <li><a href="#results-and-discussion" id="toc-results-and-discussion" class="nav-link" data-scroll-target="#results-and-discussion">Results and Discussion</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#ai-prototype-summary" id="toc-ai-prototype-summary" class="nav-link" data-scroll-target="#ai-prototype-summary">AI Prototype Summary</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="lab-6-the-internet-of-things-and-serial-peripheral-interface" class="level1">
<h1>Lab 6: The Internet of Things and Serial Peripheral Interface</h1>
<section id="introduction" class="level3">
<h3 class="anchored" data-anchor-id="introduction">Introduction</h3>
<p>In this lab, an IoT device was implemented and used to control an LED, as well as read temperatures at a user-selected bit-granularity of the temperature sensor. An ESP8266 WiFi dev board was used, along with arduino code to host the web server, and HTML generated by the MCU to host the web page. The temperature sensor used in this design is the DS1722 Digital Thermometer. UART communication was set up between the MCU and ESP8266, while the digital thermometer spoke with the MCU over SPI. This lab required that the SPI driver uses CMSIS templates, which this design implements.</p>
<p>The webpage produced by the HTML code allows for a user to control the status of an on-board LED. The status of the LED is simultaneously correctly reported on the page. The page also allows a user to select whether the temperature sensor measures temperature at 8-, 9-, 10-, 11-, or 12-bit granularity. The bit granularity implemented at the time is correctly reported on the webpage, and the temperature readings demonstrate changes in bit-granularity by an increase in significant digits at higher granularity. Finally, the temperature presently measured by the sensor is reported in degrees Celsius on the page. Temperature readings are updated any time the page is refreshed, or any time a Request is sent following a change in user-control options.</p>
</section>
<section id="design-and-testing-methodology" class="level3">
<h3 class="anchored" data-anchor-id="design-and-testing-methodology">Design and Testing Methodology</h3>
<p>Once SPI communication was understood and the datasheet was read through, an implementation for the SPI driver was written out. This design required full duplex communication, and only one peripheral to talk to. Therefore, selecting a peripheral was a trivial task, and a GPIO pin was used on the chip enable line.</p>
<p>The temperature sensor needd to first be initialized by writing the proper configuration to the address 0x80. A single-byte write required the read address, followed by the data byte, to be written to the sensor throug its SDI line. On the other hand, a single-byte read required the read address to be written to the temperature on the SDI pin. The SDO pin would immediately after respond with the data byte. The single-byte reads were executed when reading the temperature sensor, as the sensor was configured in the one-shot configuration, instead of constant conversion.</p>
<p>Any time a new request was sent from the webpage, the configuration and sensor-reading functions were executed in C.</p>
<p>Every single byte write or single byte read was encased in an assertion and deassertion of the chip enable bit, writing this bit HIGH from the GPIO.</p>
<p>The singly byte reads for temperature had to access the 0x02 and 0x01 registers to read the MSB &gt; 0 (0x02) and LSB &lt; 0 (0x01) components of the two’s complement representation produced by the sensor.</p>
</section>
<section id="technical-documentation" class="level3">
<h3 class="anchored" data-anchor-id="technical-documentation">Technical Documentation</h3>
<p>The Rx and Tx lines for UART communication used pins in GPIO port A. To avoid any potential interference between the two communication protocols, GPIO port B was enabled and utilized for PSI communication.</p>
<p>To verify that the configuration register was being accessed, and that SPI communciation was functional in the first place, the configuration register was read back after being written. A logical analyzer trace for this can be seen below. The first two bytes represent the configuration address and the proper configuration being written to the sensor, so the MISO output is irrelevant. The third byte represents the configuration read address being written to the sensor, so once again the MISO output is irrelevant. The final byte represents the configuration being written out from the temperature sensor, so the MOSI output is now irrelevant. As seen, the byte read out by the temperature sensor matches what was written two bytes prior.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/spitransaction.png" class="img-fluid figure-img"></p>
<figcaption>Figure 0: SPI Transaction</figcaption>
</figure>
</div>
<p>In order to convert the dual-register, signed two’s complement representation of temperature into a decimal value that would properly convert negative numbers and significant figures, the values extracted from the registers were manipulated. The MSB was shifted right by 8 to discard the fractional bits returned by the read temperature function. The fractional bits were similarly extracted and multiplied by 1/16 to produce the proper fractional representation, since at 12-bit resolution, the LSB could measure up to 1/(2^4) = 1/16. The sum of these were then calculated, and cast into a float. This was then printed on the webpage. To verify that negative temperatures could be handled, since no negative ambient temperatures could be reproduced, back calculations for the register-level representations of negative temperatures were made. These were then fed into the converting code, and proved to successfully print out negative values.</p>
</section>
<section id="schematic" class="level3">
<h3 class="anchored" data-anchor-id="schematic">Schematic</h3>
<p>The below schematic was implemented onto a breadboard for this design.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/schematic.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Schematic</figcaption>
</figure>
</div>
</section>
<section id="results-and-discussion" class="level3">
<h3 class="anchored" data-anchor-id="results-and-discussion">Results and Discussion</h3>
<p>This project successfully demonstrated SPI communication, as well as the ability of embedded devices to communicate with a server and digitize sensor data or other similar information.</p>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<p>This design was a successful implementation of SPI and UART communication, as well as the development of an IoT device. There was responsive and accurate communication between the temperature sensor, MCU, WiFi dev board, and webpage. This lab took me 12 hours.</p>
</section>
<section id="ai-prototype-summary" class="level3">
<h3 class="anchored" data-anchor-id="ai-prototype-summary">AI Prototype Summary</h3>
<p>I asked Gemini the prompt: I’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.</p>
<p>It responded:</p>
<pre><code>    &lt;!DOCTYPE html&gt;
    &lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;title&gt;Temperature Sensor Portal&lt;/title&gt;
        
        &lt;style&gt;
            /* --- General Styling --- */
            body {
                font-family: 'Arial', sans-serif;
                background-color: #f0f2f5;
                display: flex;
                justify-content: center;
                align-items: flex-start;
                min-height: 100vh;
                margin: 0;
                padding-top: 50px;
            }

            .container {
                background-color: #ffffff;
                padding: 30px;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                width: 100%;
                max-width: 400px;
                text-align: center;
            }

            h1 {
                color: #333;
                margin-bottom: 30px;
                font-size: 1.8em;
                border-bottom: 2px solid #eee;
                padding-bottom: 10px;
            }
            
            /* --- Temperature Display --- */
            #temperature-display {
                font-size: 4em;
                font-weight: bold;
                color: #d9534f; /* Warm color for temperature */
                margin-bottom: 20px;
            }

            .unit {
                font-size: 0.5em;
                vertical-align: top;
                display: inline-block;
                margin-left: 5px;
            }

            /* --- Control Section --- */
            .control-group {
                margin-top: 25px;
                padding: 15px;
                border: 1px solid #ddd;
                border-radius: 8px;
                text-align: left;
            }
            
            .control-group h3 {
                margin-top: 0;
                color: #555;
                font-size: 1.1em;
                border-bottom: 1px solid #eee;
                padding-bottom: 8px;
                margin-bottom: 15px;
            }

            .control-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
            }

            .control-item:last-child {
                margin-bottom: 0;
            }

            /* --- LED Control Button --- */
            #led-button {
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-weight: bold;
                transition: background-color 0.3s, box-shadow 0.3s;
            }

            .led-on {
                background-color: #5cb85c; /* Green */
                color: white;
                box-shadow: 0 2px 4px rgba(92, 184, 92, 0.4);
            }

            .led-off {
                background-color: #f0ad4e; /* Orange */
                color: white;
                box-shadow: 0 2px 4px rgba(240, 173, 78, 0.4);
            }

            #led-button:hover {
                opacity: 0.9;
            }

            /* --- Precision Control --- */
            #precision-select {
                padding: 8px;
                border-radius: 5px;
                border: 1px solid #ccc;
                background-color: #f9f9f9;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;

    &lt;div class="container"&gt;
        &lt;h1&gt;Web Sensor Interface&lt;/h1&gt;

        &lt;div class="data-display"&gt;
            &lt;h2&gt;Current Temperature&lt;/h2&gt;
            &lt;div id="temperature-display"&gt;
                24&lt;span class="unit"&gt;.50°C&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;hr&gt;
        
        &lt;div class="control-group"&gt;
            &lt;h3&gt;Device Controls&lt;/h3&gt;

            &lt;div class="control-item"&gt;
                &lt;span&gt;**LED Status:**&lt;/span&gt;
                &lt;button id="led-button" class="led-off"&gt;Turn ON&lt;/button&gt;
            &lt;/div&gt;

            &lt;div class="control-item"&gt;
                &lt;span&gt;**Readout Precision:**&lt;/span&gt;
                &lt;select id="precision-select" onchange="updateTemperature(currentTemp)"&gt;
                    &lt;option value="0"&gt;0 Decimal (25°C)&lt;/option&gt;
                    &lt;option value="1"&gt;1 Decimal (24.5°C)&lt;/option&gt;
                    &lt;option value="2" selected&gt;2 Decimals (24.50°C)&lt;/option&gt;
                    &lt;option value="3"&gt;3 Decimals (24.500°C)&lt;/option&gt;
                &lt;/select&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // --- Global State ---
        let isLedOn = false;
        let currentTemp = 24.505; // Placeholder for the full temperature value

        // --- DOM Elements ---
        const tempDisplay = document.getElementById('temperature-display');
        const ledButton = document.getElementById('led-button');
        const precisionSelect = document.getElementById('precision-select');

        // --- Functions ---

        /**
        * Toggles the LED state (simulated).
        * In a real application, this would send an AJAX/Fetch request to your sensor's backend.
        */
        function toggleLed() {
            isLedOn = !isLedOn;
            if (isLedOn) {
                ledButton.textContent = 'Turn OFF';
                ledButton.classList.remove('led-off');
                ledButton.classList.add('led-on');
                console.log("LED turned ON. (Simulated backend call)");
                // Real code: fetch('/api/led/on');
            } else {
                ledButton.textContent = 'Turn ON';
                ledButton.classList.remove('led-on');
                ledButton.classList.add('led-off');
                console.log("LED turned OFF. (Simulated backend call)");
                // Real code: fetch('/api/led/off');
            }
        }
        
        /**
        * Updates the temperature display based on the selected precision.
        * @param {number} temp - The raw temperature value.
        */
        function updateTemperature(temp) {
            const precision = parseInt(precisionSelect.value);
            const parts = temp.toFixed(precision).split('.');
            
            // Handle case where precision is 0 (no decimal part)
            const integerPart = parts[0];
            const decimalPart = parts.length &gt; 1 ? '.' + parts[1] : '';

            tempDisplay.innerHTML = `${integerPart}&lt;span class="unit"&gt;${decimalPart}°C&lt;/span&gt;`;
        }

        /**
        * Simulates fetching new sensor data and updates the display.
        * In a real application, this would run periodically via setInterval or WebSockets.
        */
        function fetchNewTemperature() {
            // In a real app, you'd use fetch:
            // fetch('/api/temperature').then(res =&gt; res.json()).then(data =&gt; { currentTemp = data.temp; updateTemperature(currentTemp); });

            // For this example, let's simulate a minor temp change:
            currentTemp = 24.505 + (Math.random() - 0.5) / 10; // Small random fluctuation
            updateTemperature(currentTemp);
        }


        // --- Event Listeners and Initial Setup ---
        
        // 1. LED Button
        ledButton.addEventListener('click', toggleLed);

        // 2. Initial Temperature Display
        updateTemperature(currentTemp);

        // 3. Simulated Live Update (fetches new temp every 5 seconds)
        setInterval(fetchNewTemperature, 5000); // Poll every 5 seconds (adjust as needed)

    &lt;/script&gt;

    &lt;/body&gt;
    &lt;/html&gt;</code></pre>
<p>Next, I asked: Write me a C function to carry out a SPI transaction to retrieve a temperature reading from a DS1722 sensor. Make use of CMSIS libraries for the STM32L432KC.</p>
<p>It responded:</p>
<pre><code>    #include "ds1722.h"
    #include &lt;stdint.h&gt;

    /**
    * @brief Performs an SPI transaction to read the temperature from the DS1722 sensor.
    * * The DS1722 expects a 1-byte read command (0x01) followed by 2 bytes of data 
    * which contain the 16-bit two's complement temperature value. The LSB is 1/128 °C.
    * * @param None
    * @return The temperature reading in degrees Celsius (float).
    */
    float DS1722_ReadTemperature(void)
    {
        // The transaction requires 1 byte for the command (0x01) followed by 2 bytes
        // of dummy data to clock out the 16-bit temperature from the sensor.
        uint8_t tx_buffer[3] = {DS1722_CMD_READ_TEMP, 0xFF, 0xFF};
        uint8_t rx_buffer[3] = {0};
        
        int16_t raw_temperature = 0;
        float temperature_celsius = 0.0f;

        // 1. Activate Chip Select (CS low)
        HAL_GPIO_WritePin(DS1722_CS_GPIO_PORT, DS1722_CS_PIN, GPIO_PIN_RESET);

        // 2. Transmit the command byte and simultaneously receive the data bytes.
        // The total transfer length is 3 bytes (Command + MSB Data + LSB Data).
        HAL_StatusTypeDef status = HAL_SPI_TransmitReceive(
            &amp;DS1722_hspi, 
            tx_buffer, 
            rx_buffer, 
            3, 
            HAL_MAX_DELAY
        );

        // 3. Deactivate Chip Select (CS high)
        HAL_GPIO_WritePin(DS1722_CS_GPIO_PORT, DS1722_CS_PIN, GPIO_PIN_SET);

        // Check for successful transmission
        if (status != HAL_OK)
        {
            // Handle error: return a distinct error value or log the issue
            // For simplicity, we return a very low value.
            return -999.0f; 
        }

        /* * The temperature data is returned in rx_buffer[1] (MSB) and rx_buffer[2] (LSB).
        * The MSB is received first.
        * Raw data format: [S S S S S S S S | D D D D D D D D]
        * MSB (rx_buffer[1]) holds the high 8 bits.
        * LSB (rx_buffer[2]) holds the low 8 bits.
        * The LSB is bit D7 (1/128 degree Celsius).
        */
        
        // Combine the 2 received bytes into a 16-bit signed integer (Two's complement)
        raw_temperature = (int16_t)((rx_buffer[1] &lt;&lt; 8) | rx_buffer[2]);

        // 4. Convert the raw two's complement value to Celsius.
        // The resolution is 1/128 °C (0.0078125 °C) per LSB.
        temperature_celsius = (float)raw_temperature / 128.0f;

        return temperature_celsius;
    }</code></pre>
<p>The HTML production was successful, however the C code did the wrong temperature conversion, multiplying the LSB by 1/128 instead of 1/16.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/Isabella-Hottenrott\.github\.io\/hmc-e155-portfolio\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>