<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>lab3 – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs/labs.html"> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../project.html"> 
<span class="menu-text">Project</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs/ai/ai.html"> 
<span class="menu-text">AI Prototypes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#lab-3-keypad-scanner" id="toc-lab-3-keypad-scanner" class="nav-link active" data-scroll-target="#lab-3-keypad-scanner">Lab 3: Keypad Scanner</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#design-and-testing-methodology" id="toc-design-and-testing-methodology" class="nav-link" data-scroll-target="#design-and-testing-methodology">Design and Testing Methodology</a></li>
  <li><a href="#technical-documentation" id="toc-technical-documentation" class="nav-link" data-scroll-target="#technical-documentation">Technical Documentation</a></li>
  <li><a href="#block-diagram" id="toc-block-diagram" class="nav-link" data-scroll-target="#block-diagram">Block Diagram</a></li>
  <li><a href="#schematic" id="toc-schematic" class="nav-link" data-scroll-target="#schematic">Schematic</a></li>
  <li><a href="#results-and-discussion" id="toc-results-and-discussion" class="nav-link" data-scroll-target="#results-and-discussion">Results and Discussion</a></li>
  <li><a href="#testbench-simulation" id="toc-testbench-simulation" class="nav-link" data-scroll-target="#testbench-simulation">Testbench Simulation</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#ai-prototype-summary" id="toc-ai-prototype-summary" class="nav-link" data-scroll-target="#ai-prototype-summary">AI Prototype Summary</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="lab-3-keypad-scanner" class="level1">
<h1>Lab 3: Keypad Scanner</h1>
<p><a href="https://github.com/Isabella-Hottenrott/e155-lab3">SOURCE CODE</a></p>
<section id="introduction" class="level3">
<h3 class="anchored" data-anchor-id="introduction">Introduction</h3>
<p>In this lab, a design was implemented on the UPduino v3.1 FPGA to scan a 4×4 matrix keypad and display a continuous stream of hexadecimal key presses on an HDSP-521A dual seven-segment LED display. Because of the limited number of FPGA pins, the design time-multiplexes the two digits. The lab addressed the challenges of handling asynchronous user inputs from the keypad and mitigating mechanical switch debouncing.</p>
</section>
<section id="design-and-testing-methodology" class="level3">
<h3 class="anchored" data-anchor-id="design-and-testing-methodology">Design and Testing Methodology</h3>
<p>To address these challenges, the design was separated into a Datapath and a Control Unit. The Datapath manages inputs, outputs, and intermediate storage and operations on signals. The Control Unit is a finite state machine (FSM) that coordinates the flow between abstract states, sending and receiving control signals to and from the Datapath.</p>
<p>Additional combinational logic encodes the relationships between the keypad’s columns and rows. The on-board iCE40 UltraPlus HSOSC high-speed oscillator was configured to generate a 12 MHz clock. This clock drives the main logic, and is also divided down to 60 Hz for the display time-multiplexing. At 60 Hz, the human eye no longer perceives individual refresh events, which prevents visible flicker.</p>
</section>
<section id="technical-documentation" class="level3">
<h3 class="anchored" data-anchor-id="technical-documentation">Technical Documentation</h3>
<section id="verilog" class="level5">
<h5 class="anchored" data-anchor-id="verilog">Verilog</h5>
<p>As introduced above, the design is structured around a Controller (FSM) and a Datapath. The FSM is responsible solely for control signals and state transitions; it is implemented as a Moore machine, where outputs depend only on the current state.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/generalidea.png" class="img-fluid figure-img" style="width:60.0%"></p>
<figcaption>Figure 0: General Inspiration of Lab 3 Design</figcaption>
</figure>
</div>
<p>My FSM is composed of six states:</p>
<pre><code>    State 0 (Scan)
    State 1 (Synch)
    State 2 (Debounce) 
    State 3 (Checking)
    State 4 (Send)
    State 5 (Release)</code></pre>
<p>State transitions proceed as follows:</p>
<pre><code>    0 → S1 when a row detects an input
    S1 → S2 when the synchronizer asserts done
    S2 → S3 when the debouncer asserts done
    S3 → S4 if the same key is still pressed; otherwise S3 → S0
    S4 → S5 unconditionally
    S5 → S0 once the key is released</code></pre>
<p>The Finite State Machine can be seen in the figure below.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fsm.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Figure 1: FSM for Lab 3 Design</figcaption>
</figure>
</div>
<p>The output and next state logic is outlined in the table below.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fsmtable.png" class="img-fluid figure-img" style="width:60.0%"></p>
<figcaption>Figure 2: Output and Next State Logic</figcaption>
</figure>
</div>
<p>The Datapath modules implement the operations required to advance the logic under control of the FSM:</p>
<section id="scancounter" class="level6">
<h6 class="anchored" data-anchor-id="scancounter">scancounter</h6>
<ul>
<li>Represents the four keypad columns as a 2-bit value. On each rising clock edge (when enabled), it increments through the four column codes, effectively sweeping the active column. It supports enable and reset control signals.</li>
</ul>
</section>
<section id="synchronizer" class="level6">
<h6 class="anchored" data-anchor-id="synchronizer">synchronizer</h6>
<ul>
<li>Consists of two flip-flops used to synchronize asynchronous row inputs to the system clock. It has enable and reset inputs and asserts a done signal exactly when synchronization completes. Conceptually, it has two internal modes: “actively synchronizing” and “synchronization done.”</li>
</ul>
</section>
<section id="debouncer" class="level6">
<h6 class="anchored" data-anchor-id="debouncer">debouncer</h6>
<ul>
<li>Implements a counter that increments on each rising edge of the 12 MHz clock while enabled. When disabled, the counter resets to zero. After 600,000 clock cycles, representing 50 ms, the module asserts a done signal, indicating that the input has remained stable long enough to be considered debounced. Like the synchronizer, it effectively has two modes: “actively counting” and “idle.”</li>
</ul>
</section>
<section id="seg_ff" class="level6">
<h6 class="anchored" data-anchor-id="seg_ff">seg_ff</h6>
<ul>
<li>A flip-flop based module that, when enabled, updates the right-hand digit with the most recent key press and shifts the previous value to the left-hand digit. This ensures that the most recent hex digit appears on the right, and the previous digit on the left. When disabled, the segments are turned off. It supports enable and reset.</li>
</ul>
</section>
</section>
<section id="breadboard" class="level5">
<h5 class="anchored" data-anchor-id="breadboard">Breadboard</h5>
<p>The HDSP-521A requires more current than the FPGA can source directly, so two 2N3906 PNP transistors were used to drive the digit anodes. Each segment cathode is connected through a 330 Ω resistor to the FPGA, chosen to provide approximately 3 mA of segment current over the effective drop:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/resistor.png" class="img-fluid figure-img" style="width:60.0%"></p>
<figcaption>Figure 3: Resistor Calculation</figcaption>
</figure>
</div>
<p>A 460 Ω resistor is placed between each transistor base and the corresponding GPIO pin to limit the base current to under 5 mA, as required by the device datasheet.</p>
<p>The priority encoder converts the 4-bit hex values into the appropriate seven-segment patterns, which are mapped to the HDSP-521A input pins.</p>
<p>The keypad has eight pins (four rows and four columns), wired as follows from Pin 0 to Pin 8: {R0, C0, R3, R1, R2, C1, C2, C3}, where Rx denotes a row and Cx denotes a column. The columns are driven active-high by FPGA GPIO pins. The rows are read by FPGA inputs and tied to 100 kΩ pull-down resistors to prevent floating values.</p>
</section>
</section>
<section id="block-diagram" class="level3">
<h3 class="anchored" data-anchor-id="block-diagram">Block Diagram</h3>
<p>The top-level module is lab3_ih with the following interface: * Inputs reset – from the development board inputrows – from the keypad row lines * Outputs cols – to the keypad column drivers segmentOut – to the shared segment cathodes anodeZeroOut – to the base of transistor 0 (digit 0) anodeOneOut – to the base of transistor 1 (digit 1)</p>
<p>lab3_ih instantiates nine submodules:</p>
<ol type="1">
<li>hf_osc – high-speed oscillator primitive</li>
<li>clock_div – divides 12 MHz down to 60 Hz for display multiplexing</li>
<li>FSM – control unit implementing the six-state machine</li>
<li>DataPath – encapsulating the datapath logic</li>
<li>colrowseg0, colrowseg1 – column/row to segment encoders for each digit</li>
<li>segments0, segments1 – seven-segment decoders for the two digits</li>
<li>anodeselect – selects which digit’s anode is active based on the multiplexing clock</li>
</ol>
<p>Inside DataPath.sv, five additional submodules are instantiated:</p>
<ul>
<li>scancounter – cycles through keypad columns</li>
<li>combcol – encodes the active column</li>
<li>synchronizer – synchronizes row inputs to the clock domain</li>
<li>debouncer – debounces mechanical switching</li>
<li>seg_ff – updates and stores the two displayed hex digits</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/blockdiagram.png" class="img-fluid figure-img"></p>
<figcaption>Figure 5: Block Diagram</figcaption>
</figure>
</div>
</section>
<section id="schematic" class="level3">
<h3 class="anchored" data-anchor-id="schematic">Schematic</h3>
<p>The schematic shows the physical wiring on the breadboard: Corresponding cathodes from the two digits of the dual display share the same node (e.g., digit 1 segment A and digit 2 segment A). Each shared node is connected in series with a 330 Ω current-limiting resistor to a GPIO pin. The on-board LEDs use 1 kΩ resistors for current limiting. For each PNP transistor, the emitter is tied to 3.3 V, the collector drives the common anode of the segment anodes, and the base is in series with a 460 Ω resistor from a GPIO pin. Keypad columns are wired directly from FPGA GPIO outputs. Keypad rows are wired to FPGA GPIO inputs and additionally connected to 100 kΩ pull-down resistors.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/schematic.png" class="img-fluid figure-img"></p>
<figcaption>Figure 6: Schematic</figcaption>
</figure>
</div>
</section>
<section id="results-and-discussion" class="level3">
<h3 class="anchored" data-anchor-id="results-and-discussion">Results and Discussion</h3>
<p>This design met the intended objectives. All module-level testbenches passed. The dual seven-segment display correctly showed the hex digits corresponding to keypad inputs. The system did not lock or get confused when an invalid, asynchronous, or mechanically-bounced input was punched in. The two digits were clearly illuminated and visually distinct, with no noticeable flicker.</p>
</section>
<section id="testbench-simulation" class="level3">
<h3 class="anchored" data-anchor-id="testbench-simulation">Testbench Simulation</h3>
<p>A testbench simulation was produced for every module in the design.</p>
<section id="tb_lab3_ih" class="level4">
<h4 class="anchored" data-anchor-id="tb_lab3_ih">tb_lab3_ih:</h4>
<p>The testbench for lab3_ih can be found <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/fpga/tb_lab3_ih.sv">here</a>. Seven different button presses were tested and proven to output the correct value, including corner cases, such as what happens when there is a double press, or what happens when second press is asserted while the first press is still held. The testbench also verified that the column scan stops when expected, and that the row/column encoding matches the intended key. Correct segment outputs and anode control were observed. No errors occurred.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/tb_lab3_ihi.png" class="img-fluid figure-img"></p>
<figcaption>Figure 7: Testbench Simulation Results for lab3_ih</figcaption>
</figure>
</div>
</section>
<section id="tb_datapath" class="level4">
<h4 class="anchored" data-anchor-id="tb_datapath">tb_DataPath:</h4>
<p>The testbench for the DataPath module can be found <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/fpga/tb_DataPath.sv">here</a>. This testbench exercises different combinations of control signals from the FSM and verifies the timing and coherence of all DataPath submodules. It includes both typical use cases and corner cases (such as invalid inputs). No errors occurred.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/tb_datapathi.png" class="img-fluid figure-img"></p>
<figcaption>Figure 8: Testbench Simulation Results for DataPath</figcaption>
</figure>
</div>
</section>
<section id="tb_fsm" class="level4">
<h4 class="anchored" data-anchor-id="tb_fsm">tb_FSM:</h4>
<p>The testbench for the FSM module can be found <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/fpga/tb_FSM.sv">here</a>. All combinations of FSM inputs were tested. The testbench tracked both the current state and next state to ensure they matched the expected transitions. Two full cycles through the FSM were simulated. No errors occurred.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/tb_fsm.png" class="img-fluid figure-img"></p>
<figcaption>Figure 9: Testbench Simulation Results for FSM</figcaption>
</figure>
</div>
</section>
<section id="tb_combcol" class="level4">
<h4 class="anchored" data-anchor-id="tb_combcol">tb_CombCol:</h4>
<p>The testbench for the CombCol module can be found <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/fpga/tb_CombCol.sv">here</a>. This testbench tested all different possible combinations of inputs into the CombCol module- a simple encoder. No errors occured.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/tb_fsm.png" class="img-fluid figure-img"></p>
<figcaption>Figure 10: Testbench Simulation Results for CombCol</figcaption>
</figure>
</div>
</section>
<section id="tb_clock_div" class="level4">
<h4 class="anchored" data-anchor-id="tb_clock_div">tb_clock_div:</h4>
<p>The testbench for the clock divider module can be found <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/fpga/tb_clock_div.sv">here</a>. A test oscillator was produced that ticked every 100000 time stamps, where two time stamps represent a full clock cycle. The test oscillator was compared to that produced by the clock_div module when fed in the testbench clock signal. Both oscillators can be seen to rise and fall simulataneously. The HSOSC produces a 12 MHz clock. The clock divider module has been shown to divide the input clock signal by 200000. 12 MHz/200000 = 60 Hz, which is the targeted frequency switching between displays. No errors occured.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/tb_clock_div.png" class="img-fluid figure-img"></p>
<figcaption>Figure 11: Testbench Simulation Results for clock_div</figcaption>
</figure>
</div>
</section>
<section id="tb_anodeselect" class="level4">
<h4 class="anchored" data-anchor-id="tb_anodeselect">tb_anodeselect:</h4>
<p>The testbench for the anodeselect module can be found <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/fpga/tb_anodeselect.sv">here</a>. The test verifies that the correct segment output and segment anode are sent off the FPGA at the correct multiplexed timestamp. The test verifies that the two segments are never sent out at the same time. No errors occured.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/tb_anodeselect.png" class="img-fluid figure-img"></p>
<figcaption>Figure 12: Testbench Simulation Results for anodeselect</figcaption>
</figure>
</div>
</section>
<section id="tb_colrowseg" class="level4">
<h4 class="anchored" data-anchor-id="tb_colrowseg">tb_colrowseg:</h4>
<p>The testbench for the colrowseg module can be found <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/fpga/tb_colrowseg.sv">here</a>. The test asserts all possible inputs for this combinational module. No errors occured.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/tb_colrowseg.png" class="img-fluid figure-img"></p>
<figcaption>Figure 13: Testbench Simulation Results for colrowseg</figcaption>
</figure>
</div>
</section>
<section id="tb_debouncer" class="level4">
<h4 class="anchored" data-anchor-id="tb_debouncer">tb_debouncer:</h4>
<p>The testbench for the debouncer module can be found <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/fpga/tb_debouncer.sv">here</a>. The testbench verifies the enable behavior of the debouncer and confirms that 600,000 clock cycles are required before the done signal asserts. At 12 MHz, this corresponds to 50 ms. No errors occurred.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/tb_debouncer.png" class="img-fluid figure-img"></p>
<figcaption>Figure 14: Testbench Simulation Results for debouncer</figcaption>
</figure>
</div>
</section>
<section id="tb_scancounter" class="level4">
<h4 class="anchored" data-anchor-id="tb_scancounter">tb_scancounter:</h4>
<p>The testbench for the scancounter module can be found <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/fpga/tb_scancounter.sv">here</a>. This testbench verifies that the scanning of columns cycles through columns and equal and even amount. Correct response to the enable signal was proven. No errors occured.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/tb_scancounter.png" class="img-fluid figure-img"></p>
<figcaption>Figure 15: Testbench Simulation Results for scancounter</figcaption>
</figure>
</div>
</section>
<section id="tb_seg_ff" class="level4">
<h4 class="anchored" data-anchor-id="tb_seg_ff">tb_seg_ff:</h4>
<p>The testbench for the seg_ff module can be found <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/fpga/tb_seg_ff.sv">here</a>. A variety of different test cases were tested against the seg_ff module. Different row and column values were tested, including invalid ones, producing segment0 and segment1 signals. Correct response to the enable signal was proven. No errors occured.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/tb_seg_ff.png" class="img-fluid figure-img"></p>
<figcaption>Figure 16: Testbench Simulation Results for seg_ff</figcaption>
</figure>
</div>
</section>
<section id="tb_synchronizer" class="level4">
<h4 class="anchored" data-anchor-id="tb_synchronizer">tb_synchronizer:</h4>
<p>The testbench for the synchronizer module can be found <a href="https://github.com/Isabella-Hottenrott/e155-lab3/blob/main/fpga/tb_synchronizer.sv">here</a>. This testbench confirms that, after two clock cycles, the asynchronous input is correctly synchronized to the clock domain. It also verifies the behavior of the enable input and the timing of the done signal. No errors occurred.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/tb_synchronizer.png" class="img-fluid figure-img"></p>
<figcaption>Figure 17: Testbench Simulation Results for synchronizer</figcaption>
</figure>
</div>
</section>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/scanner.jpeg" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Figure 18: Scanner in Action</figcaption>
</figure>
</div>
<p>This design successfully scanned a 4×4 keypad and drove a dual seven-segment display using time-multiplexed outputs. It handled asynchronous inputs and mechanical switch bounce without lockup or misinterpretation, and the chosen components and operating points provided strong, consistent illumination. The architecture—separating FSM control from a structured Datapath—resulted in a modular design that was straightforward to test and verify.</p>
</section>
<section id="ai-prototype-summary" class="level3">
<h3 class="anchored" data-anchor-id="ai-prototype-summary">AI Prototype Summary</h3>
<p>I provided the LLM three different prompts for this lab to see how it would perform depending on the content of the prompts.</p>
<p>The LLM’s response, as well as my evaluation of the response, can be found <a href="../../labs/ai/ai.html">here</a></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/Isabella-Hottenrott\.github\.io\/hmc-e155-portfolio\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>