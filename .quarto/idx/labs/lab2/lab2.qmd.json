{"title":"Lab 2: Multiplexed 7-Segment Display","markdown":{"headingText":"Lab 2: Multiplexed 7-Segment Display","containsRefs":false,"markdown":"\n\n### Introduction\nIn this lab, a design was implemented on the UPduino v3.1 FPGA that time-multiplexed between two seven-segment displays. The design utilized only one set of GPIO pins, and only one seven segment HDL module. The time multiplexing occured at a fast enough rate that switching between segments was not discernable to the human eye.\n\n### Design and Testing Methodology\nThe iCE40 UltraPlus HSOSC primitive was used to generate a clock signal, which was stepped down to a 60 Hz signal that the design was based on. At this frequency, the human eye can no longer percieve refresh rates. This frequency also ensured that bleeding did not occur between the two segments.\n\nAn 8-pin dip switch controls the HDSP-521A Dual Seven Segment Display, where the first four switches correspond to the first segment, and final four correspond to the second. When the internal clock is low, the input from the first four switches is selected, and when the clock is high, the input from the final four are selected.\n\nAt the same time, when the clock is low, a signal is sent to drive the common anode of the first segment. When the clock is high, a separate signal drives the common anode of the second segment.\n\nThe sum of the two hex values on the HDSP-521A Display is represented in binary on the on-board LEDs of the E155 Development Board. These diodes are in series with 1 kΩ resistors to limit current. \n\nThe Seven Segment Display module- a priority encoder- was used to convert the desired switch inputs into an output hex digit. The HDSP521A required a larger current draw than the FPGA can output, which was addressed by two 2N3906 PNP transistors. 330 Ω resistors were placed at the cathodes of the diodes to ensure a 3 mA current pull through the segment, over the (3.3 V - 0.25 Vce -1.85 Vf) = 1.2 V drop, when ON. Calculations for the current limiting resistors between the cathodes and GPIO pins can be found below. \n\n\n![Figure 0: Resistor Calculation](images/resistor.png){width=40% fig-align=\"center\"}\n\nA 460 Ω resistor was placed between the transisotr base and the GPIO pin to limit the current draw to under 5 mA through the base, as specified by the datasheet. Calculations for this component value can be found below. \n\n![Figure 1: Transistor Base Current Calculation](images/transbase.png){width=40% fig-align=\"center\"}\n\nTo control the input to the Seven Segment Display, a priority encoder was used. The output signals were mapped to their respective pins on the input of the HDSP-511A Seven Segment Display. \n\n\n\n### Technical Documentation\n\nThe source code for Lab 2 can be found in the following [GitHub repository](https://github.com/Isabella-Hottenrott/e155-lab2).\n\n### Block Diagram\n\n![Figure 2: Block Diagram of the lab2_ih verilog design](images/blockdiagram.png){fig-align=\"center\"}\n\nThe block diagram above illustrates the lab2_ih design. The top level module is called lab2_ih and takes in inputs: reset, sw1, and sw2. Lab2_ih outputs to five leds (led), a single set of GPIO pins for the dual seven segment (segs), to both transistors to illuminate the proper segment anode (anodeOne, anodeTwo), and to the two remaining on-board LEDs to keep them from floating (bottomLEDs). Lab2_ih includes five submodules: the high-speed oscillator block (hf_osc), the clock divider to 60 Hz (clock_div), the adder (adder), the seven segments priority encoder (segments), and the anode-selecting module (anodeselect).\n\n### Schematic\n\nThe schematic above illustrates the physical layout on the breadboard. Corresponding diode cathodes from the two seven segment displays were the same node (segment 1 A is the same node as segment 2 A, etc). These were connected in series with a 330 Ω current-limiting resistor to the GPIO pins. The on-board LEDs required 1 kΩ resistors to their limit current. The emitter of the transistor is powered by 3.3 V, while the collector goes straight to the segment anodes. The base of the PNP transistor is in series with a 460 Ω resistor such that less than 5mA of current is drawn from the GPIO pin, which lies within specs.\n\n\n![Figure 3: Schematic of the Breadboard](images/schematic.png){fig-align=\"center\"}\n\n### Results and Discussion\nThis design met the intended objectives. All switches correctly spoke with the board, the proper LED-sum combinations were calculated and illuminated, and the Seven Segment Display shows two distinct hex values without any discernable flickering or bleeding.\n\n### Testbench Simulation\nA testbench simulation was produced for every module in the design. \n\n#### tb_lab2_ih:\nThe testbench for lab2_ih can be found [here](https://github.com/Isabella-Hottenrott/e155-lab2/blob/main/fpga/source/impl_1/tb_lab2_ih.sv). The high speed clock was commented out to run this simulation, and 10 known cases were tested against the design. No errors occured. \n\n![Figure 4: Testbench Simulation Results for lab2_ih](images/tb_lab2.png){fig-align=\"center\"}\n\n#### tb_segments:\nThe testbench for the segments module can be found [here](https://github.com/Isabella-Hottenrott/e155-lab2/blob/main/fpga/source/impl_1/tb_segments.sv). All possible combinations of input switch values were explicitly tested. No errors occured. \n\n![Figure 5: Testbench Simulation Results for segments](images/tb_segments.png){fig-align=\"center\"}\n\n#### tb_clock_div:\nThe testbench for the clock divider module can be found [here](https://github.com/Isabella-Hottenrott/e155-lab2/blob/main/fpga/source/impl_1/tb_clock_div.sv). A test oscillator was produced that ticked every 800000 time stamps, where two time stamps represent a full clock cycle. The test oscillator was compared to that produced by the clock_div module when fed in the testbench clock signal. Both oscillators can be seen to rise and fall simulataneously. The HSOSC produces a 48 MHz clock. The clock divider module has been shown to divide the input clock signal by 800000. 48 MHz/800000 = 60 Hz, which is the targeted frequency switching between displays. No errors occured. \n\n![Figure 6: Testbench Simulation Results for clock_div](images/tb_clk_div.png){fig-align=\"center\"}\n\n#### tb_anodeselect:\nThe testbench for the anodeselect module can be found [here](https://github.com/Isabella-Hottenrott/e155-lab2/blob/main/fpga/source/impl_1/tb_anodeselect.sv). The test verifies that the correct switch value is sent to the segment modules, as well as the corresponding correct anode, across 12 handwritten vectors. The test verifies that the two anodes are never HIGH at the same timestamp. No errors occured. \n\n![Figure 7: Testbench Simulation Results for anodeselect](images/tb_anodeselect.png){fig-align=\"center\"}\n\n#### tb_adder:\nThe testbench for the adder module can be found [here](https://github.com/Isabella-Hottenrott/e155-lab2/blob/main/fpga/source/impl_1/tb_adder.sv). A system verilog function iterates through all possible input-addition combinations to verify all possible additions. No errors occured. \n\n ![Figure 8: Testbench Simulation Results for adder](images/tb_adder.png){fig-align=\"center\"}\n\n### Conclusion\n\nThis design design illuminated a Dual Seven Segment Display using a single segment module through the use of time-multiplexing. A transistor circuit and selected resistors were used to ensure that sufficient, but not excessive current, flows through components based on datasheet values. I spent a total of 18 hours on this lab.\n\n### AI Prototype Summary\n\nThe prompt that I provided the LLM was: \"Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\"\nIn return, I recieved the following design that did not synthesize:\n\n    // Time Multiplexed Seven Segment Display Controller\n    // This module uses a single seven segment decoder to drive two displays\n\n    module seven_seg_mux (\n        input  logic        clk,\n        input  logic        reset_n,\n        input  logic [3:0]  digit0_in,    // First 4-bit input\n        input  logic [3:0]  digit1_in,    // Second 4-bit input\n        output logic [6:0]  seg0_out,     // Seven segment outputs for display 0\n        output logic [6:0]  seg1_out,     // Seven segment outputs for display 1\n        output logic        digit0_enable, // Enable signal for display 0\n        output logic        digit1_enable  // Enable signal for display 1\n    );\n\n        // Internal signals\n        logic [3:0] mux_input;\n        logic [6:0] decoder_output;\n        logic       mux_select;\n        logic       slow_clk;\n\n        // Instantiate oscillator for timing\n        oscillator u_osc (\n            .clk(clk),\n            .reset_n(reset_n),\n            .slow_clk(slow_clk)\n        );\n\n        // Generate multiplexer select signal\n        always_ff @(posedge slow_clk or negedge reset_n) begin\n            if (!reset_n)\n                mux_select <= 1'b0;\n            else\n                mux_select <= ~mux_select;\n        end\n\n        // Input multiplexer\n        always_comb begin\n            case (mux_select)\n                1'b0: mux_input = digit0_in;\n                1'b1: mux_input = digit1_in;\n            endcase\n        end\n\n        // Instantiate seven segment decoder\n        seven_seg_decoder u_decoder (\n            .bin_in(mux_input),\n            .seg_out(decoder_output)\n        );\n\n        // Output demultiplexer and enable generation\n        always_comb begin\n            case (mux_select)\n                1'b0: begin\n                    seg0_out = decoder_output;\n                    seg1_out = 7'b1111111;  // All segments off (common anode)\n                    digit0_enable = 1'b0;   // Active low enable\n                    digit1_enable = 1'b1;   // Disabled\n                end\n                1'b1: begin\n                    seg0_out = 7'b1111111;  // All segments off\n                    seg1_out = decoder_output;\n                    digit0_enable = 1'b1;   // Disabled\n                    digit1_enable = 1'b0;   // Active low enable\n                end\n            endcase\n        end\n\n    endmodule\n\n    // Seven Segment Decoder Module\n    // Converts 4-bit binary input to seven segment display pattern\n    // Common anode configuration (active low outputs)\n    module seven_seg_decoder (\n        input  logic [3:0] bin_in,\n        output logic [6:0] seg_out\n    );\n\n        // Segment mapping: seg_out = {g, f, e, d, c, b, a}\n        // Common anode: 0 = segment on, 1 = segment off\n        always_comb begin\n            case (bin_in)\n                4'h0: seg_out = 7'b1000000; // 0\n                4'h1: seg_out = 7'b1111001; // 1\n                4'h2: seg_out = 7'b0100100; // 2\n                4'h3: seg_out = 7'b0110000; // 3\n                4'h4: seg_out = 7'b0011001; // 4\n                4'h5: seg_out = 7'b0010010; // 5\n                4'h6: seg_out = 7'b0000010; // 6\n                4'h7: seg_out = 7'b1111000; // 7\n                4'h8: seg_out = 7'b0000000; // 8\n                4'h9: seg_out = 7'b0010000; // 9\n                4'hA: seg_out = 7'b0001000; // A\n                4'hB: seg_out = 7'b0000011; // b\n                4'hC: seg_out = 7'b1000110; // C\n                4'hD: seg_out = 7'b0100001; // d\n                4'hE: seg_out = 7'b0000110; // E\n                4'hF: seg_out = 7'b0001110; // F\n            endcase\n        end\n\n    endmodule\n\n    // Simple Oscillator Module\n    // Generates a slower clock for multiplexing\n    module oscillator (\n        input  logic clk,\n        input  logic reset_n,\n        output logic slow_clk\n    );\n\n        parameter DIVIDE_BY = 100000; // Adjust for desired refresh rate\n        logic [$clog2(DIVIDE_BY)-1:0] counter;\n\n        always_ff @(posedge clk or negedge reset_n) begin\n            if (!reset_n) begin\n                counter <= '0;\n                slow_clk <= 1'b0;\n            end else begin\n                if (counter == DIVIDE_BY - 1) begin\n                    counter <= '0;\n                    slow_clk <= ~slow_clk;\n                end else begin\n                    counter <= counter + 1;\n                end\n            end\n        end\n\n    endmodule\n\n    // Testbench for verification\n    module seven_seg_mux_tb;\n\n        logic        clk;\n        logic        reset_n;\n        logic [3:0]  digit0_in;\n        logic [3:0]  digit1_in;\n        logic [6:0]  seg0_out;\n        logic [6:0]  seg1_out;\n        logic        digit0_enable;\n        logic        digit1_enable;\n\n        // Instantiate DUT\n        seven_seg_mux dut (\n            .clk(clk),\n            .reset_n(reset_n),\n            .digit0_in(digit0_in),\n            .digit1_in(digit1_in),\n            .seg0_out(seg0_out),\n            .seg1_out(seg1_out),\n            .digit0_enable(digit0_enable),\n            .digit1_enable(digit1_enable)\n        );\n\n        // Clock generation\n        initial begin\n            clk = 0;\n            forever #5 clk = ~clk;\n        end\n\n        // Test stimulus\n        initial begin\n            reset_n = 0;\n            digit0_in = 4'h0;\n            digit1_in = 4'h0;\n\n            #100 reset_n = 1;\n\n            // Test different digit combinations\n            #1000 digit0_in = 4'h3; digit1_in = 4'h7;\n            #2000 digit0_in = 4'hA; digit1_in = 4'hF;\n            #2000 digit0_in = 4'h5; digit1_in = 4'h2;\n\n            #5000 $finish;\n        end\n\n        // Monitor outputs\n        initial begin\n            $monitor(\"Time=%0t, digit0_in=%h, digit1_in=%h, seg0=%b, seg1=%b, en0=%b, en1=%b\", \n                    $time, digit0_in, digit1_in, seg0_out, seg1_out, digit0_enable, digit1_enable);\n        end\n\n    endmodule\n\n\nNext, I asked the LLM to: \"Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\" and attached my Lab 1 files. I received the following design that, again, did not synthesize. \n\n    // Isabella Hottenrott's segments module\n    // segments.sv\n    // Module containing Verilog code for Seven-segment display mapping\n    module segments(input logic [3:0] digit,\n                    output logic [6:0] segs);\n\n    always_comb\n    case(digit)\n        0:  segs = 7'b000_0001; //0\n        1:  segs = 7'b100_1111; //1\n        2:  segs = 7'b001_0010; //2\n        3:  segs = 7'b000_0110; //3\n        4:  segs = 7'b100_1100; //4\n        5:  segs = 7'b010_0100; //5\n        6:  segs = 7'b010_0000; //6\n        7:  segs = 7'b000_1111; //7\n        8:  segs = 7'b000_0000; //8\n        9:  segs = 7'b000_1100; // 9\n        10: segs = 7'b000_1000; //a\n        11: segs = 7'b110_0000; //b\n        12: segs = 7'b011_0001; //c\n        13: segs = 7'b100_0010; //d\n        14: segs = 7'b011_0000; //e\n        15: segs = 7'b011_1000; //f\n        default:    segs = 7'b111_1111;\n    endcase\n    endmodule\n\n    // Simple oscillator module for timing control\n    module oscillator(input logic clk,\n                  input logic reset,\n                  output logic slow_clk);\n    \n    parameter DIVIDE_RATIO = 50000; // Adjust for desired refresh rate\n    logic [$clog2(DIVIDE_RATIO)-1:0] counter;\n    \n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter <= 0;\n            slow_clk <= 0;\n        end else begin\n            if (counter == DIVIDE_RATIO - 1) begin\n                counter <= 0;\n                slow_clk <= ~slow_clk;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n    endmodule\n\n    module seven_seg_time_mux(\n        input logic clk,\n        input logic reset,\n        input logic [3:0] digit0,    // First 4-bit input\n        input logic [3:0] digit1,    // Second 4-bit input\n        output logic [6:0] segs0,    // Seven segment outputs for display 0\n        output logic [6:0] segs1     // Seven segment outputs for display 1\n    );\n\n    // Internal signals\n    logic [3:0] mux_digit;       // Multiplexed input to decoder\n    logic [6:0] decoder_segs;    // Output from segments decoder\n    logic mux_select;            // Select signal for multiplexing\n    logic slow_clk;              // Slower clock for multiplexing\n    \n    // Instantiate oscillator for timing control\n    oscillator timing_gen (\n        .clk(clk),\n        .reset(reset),\n        .slow_clk(slow_clk)\n    );\n    \n    // Generate multiplexer select signal (toggles between displays)\n    always_ff @(posedge slow_clk or posedge reset) begin\n        if (reset)\n            mux_select <= 1'b0;\n        else\n            mux_select <= ~mux_select;\n    end\n    \n    // Input multiplexer - select which digit to decode\n    always_comb begin\n        case (mux_select)\n            1'b0: mux_digit = digit0;\n            1'b1: mux_digit = digit1;\n            default: mux_digit = digit0;\n        endcase\n    end\n    \n    // Instantiate Isabella's segments decoder\n    segments decoder (\n        .digit(mux_digit),\n        .segs(decoder_segs)\n    );\n    \n    // Output demultiplexer - route decoder output to appropriate display\n    // When a display is not selected, turn off all segments (common anode = all high)\n    always_comb begin\n        case (mux_select)\n            1'b0: begin\n                segs0 = decoder_segs;    // Display digit0\n                segs1 = 7'b111_1111;     // Turn off display 1\n            end\n            1'b1: begin\n                segs0 = 7'b111_1111;     // Turn off display 0\n                segs1 = decoder_segs;    // Display digit1\n            end\n            default: begin\n                segs0 = 7'b111_1111;\n                segs1 = 7'b111_1111;\n            end\n        endcase\n    end\n\nendmodule\n\n    logic clk;\n    logic reset;\n    logic [3:0] digit0;\n    logic [3:0] digit1;\n    logic [6:0] segs0;\n    logic [6:0] segs1;\n    \n    // Instantiate the Device Under Test (DUT)\n    seven_seg_time_mux dut (\n        .clk(clk),\n        .reset(reset),\n        .digit0(digit0),\n        .digit1(digit1),\n        .segs0(segs0),\n        .segs1(segs1)\n    );\n    \n    // Clock generation (50MHz system clock)\n    initial begin\n        clk = 0;\n        forever #10 clk = ~clk; // 20ns period = 50MHz\n    end\n    \n    // Test stimulus\n    initial begin\n        // Initialize signals\n        reset = 1;\n        digit0 = 4'h0;\n        digit1 = 4'h0;\n        \n        // Release reset\n        #100 reset = 0;\n        \n        // Test case 1: Display 3 and 7\n        #1000 digit0 = 4'h3; digit1 = 4'h7;\n        \n        // Test case 2: Display A and F (hex)\n        #5000 digit0 = 4'hA; digit1 = 4'hF;\n        \n        // Test case 3: Display 5 and 2\n        #5000 digit0 = 4'h5; digit1 = 4'h2;\n        \n        // Test case 4: Display 8 and 1\n        #5000 digit0 = 4'h8; digit1 = 4'h1;\n        \n        // Finish simulation\n        #10000 $finish;\n    end\n    \n    // Monitor key signals\n    initial begin\n        $monitor(\"Time=%0t, digit0=%h, digit1=%h, segs0=%b, segs1=%b\", \n                 $time, digit0, digit1, segs0, segs1);\n    end\n    \n    // Generate VCD file for waveform viewing\n    initial begin\n        $dumpfile(\"seven_seg_mux.vcd\");\n        $dumpvars(0, seven_seg_time_mux_tb);\n    end\n\nendmodule\n\n\nBoth designs ran into the issue that the \"loop count limit [of the clock] exceeded forever never breaks\". This occured because both LLM outputs created associated testbenches. I tried to take out this forever statement, and make the clock tick similarly to my own testbenches. However, when I did this, I received a \"Synthesize Design Completed, Lattice Synthesis Engine Failed\" error.","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"lab2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.33","theme":["cosmo","brand"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}